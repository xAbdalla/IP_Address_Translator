import os
import re
import sys
import time
import base64
import socket
import ipaddress
import threading
import subprocess
import xlsxwriter
import dns.resolver
import pandas as pd
from datetime import datetime
from datetime import timedelta
from paramiko import SSHClient
from paramiko import AutoAddPolicy
from dns.nameserver import Nameserver
from fortigate_api import FortiGateAPI
from typing_extensions import Sequence

import tkinter as tk
from tkinter import ttk
from tkinter import Canvas
from tkinter import constants
from tkinter import filedialog
from tkinter import messagebox

from Crypto import Random
from Crypto.Cipher import AES
from Crypto.Hash import SHA256


# Icons Data
ICON_DATA = (
    "iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN8wAADfMBL/09/gAAABl0RVh0"
    "U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAEVhSURBVHja7d15cFZFvv/xO+hQOjqOVWPV+Ac1NZQ1NTX1u/fqFXFAUAOioEDY"
    "d8hGgLCEBBISIAtJCIEkQJB9X8ISQEAxbqCsKsuwDMqOgDIqyDjoMMoO6V/3w8FBDZDlefp0n/Om6lX1q/u7V6VPn+/385xzuvu/hBD/"
    "BcBsEz5dfq9US3pUaix1kOKkNGm8tEBaIZVKa6SN0lZpl7RP+kQ6IX0lfSudk646zjn/s6+c/51PnP+bXc4/Y6Pzzyx1/h0LnH9nmvPf"
    "0MH5b3rU+W+8l2sGmI9BANxt7DWlR6QmUqw0SlosrZP2SJ9L5yVhmfPOf/se5++y2Pm7xTp/V/V3rskcAAgAgFcbfA3pD1KYFC1lS8XS"
    "ZqdBXrOwuQfLNWcMNjtjku2MUZgzZjWYQwABALCh2T/kPApPkOZIOyz99W7SU4QdzlgmOGP7EHMNIAAAbj62V++7e0iF0jvSSRq2Nied"
    "MS90rsGjvE4ACABAKBq+el8dIc2U9kpXaMLGueJcm5nOtXqEuQsQAIDKNPu7pbpSovPF+ymaq7VOOdcw0bmmdzPHAQIAcKPhPyA1lXKk"
    "9c6SOJqnN51zrnGOc80f4B4AAQDw11f59Zwvzrf7/Ct8v7vmzIFsZ06w6gAEAMBjTf9hKVIqkc7Q+HALZ5w5oubKw9w7IAAAdr7Hf0bK"
    "k3ZLZTQ3VFKZM3fynLnE9wMgAACGNv3fOL/cVkpnaWAIsrPO3FJz7DfccyAAAO42/V9L3aTXpUs0KWhyyZlzau79mnsRBABAT9O/T+ok"
    "rZIu0IzgsgvOXFRz8j7uURAAgOA2fXUSXjtpOcv0YPgyw+XOXOVERBAAgGos12smLZG+o7nAMt85c7cZywtBAAAq1vjVefKZzrn0NBJ4"
    "wQlnTtfiHgcBAPhx079LCpdKpas0DHjUVWeOq7l+F/c+CADwc+OvLeVKX9Ic4DNfOnO/NrUABAD4pen/UmovrWWDHiBwD6x17olfUiNA"
    "AIAXG/9DznvQ0xR9oFynnXvkIWoGCADwQuP/ozRNOk+BByrkvHPP/JEaAgIAbGz8DaVXOW0PqNZpheoeakhNAQEANnzNr95lbqN4A0G1"
    "zbm3WD0AAgCM2543XjpGoQZC6rhzr7HtMAgAcLXxP+B8tPQNhRnQ6hvn3nuAWgQCAHT/4k+VzlCIAVedce5FngiAAICQNv57pEEs5QOM"
    "XEKo7s17qFUgACCYjb+m1I8d+wArdhhU92pNahcIAKhO479biuVgHsDKA4jUvXs3tQwEAFSm8aujeHtIRymkgNWOOvcyRxKDAIA7Nv8w"
    "aQ+FE/AUdU+HUeNAAMCtTuZbSaEEPG0lJxCCAIAbjf9+KU+6SHEEfOGic8/fTw0kAMCfjf8XUpR0ioII+NIppwb8gppIAIB/mn8DaQcF"
    "EIBTCxpQGwkA8Hbj/71UQsEDUA5VG35PrSQAwHun9CVL5yhyAG7jnFMrOHWQAAAPNP/HpJ0UNgCVoGrGY9RQAgDs3bd/jHSFYgagCq44"
    "NYTzBQgAsGwznyMUMABBcIRNhAgAML/xPyjNksooWgCCqMypLQ9SawkAMK/5t5VOUqgAhJCqMW2puQQAmNH4H5ZWUZgAaKRqzsPUYAIA"
    "3Gv+4dLXFCMALlC1J5xaTACA3sb/K2k6BQiAAVQt+hW1mQCA0Df/x6VDFB0ABlE16XFqNAEAoWn8NaQU6TLFBoCBLjs1qgY1mwCA4DX/"
    "WtJ6CgwAC6haVYvaTQBA9Zt/B+kbigoAi6ia1YEaTgBA1Rr//dI8CgkAi6kadj81nQCAijf/P0kHKB4APEDVsj9R2wkAuHPzby2dpWgA"
    "8BBV01pT4wkAuPVX/nns4w/Aw+cJ5LFKgACAHzf/30prKBAAfEDVut9S+wkANP/rG/t8RlEA4COfsXEQAcDvzT9KukAxAOBDqvZF0QsI"
    "AH5r/DWlqRQAAAjUwpr0BgKAH5r/76Qt3PQA8ANVE39HjyAAeLn5/1n6lJsdAH5G1cY/0ysIAF5s/o2kb7nJAeCWVI1sRM8gAHip+UdM"
    "4BQ/AKgIVSsj6B0EAC80/yxuaACotCx6CAHA5i/9i7mJAaDKilkhQACwrfk/KG3g5gWAalO19EF6CwHAhuZfewIn+QFAMKmaWpseQwAw"
    "ufnXkU5zswJA0KnaWodeQwAwsfk3nMAxvgAQSqrGNqTnEABMav7PS+e4OQEg5FStfZ7eQwAwofm3ki5yUwKANqrmtqIHEQDcbP5dpCvc"
    "jACgnaq9XehFBAA3mn+sdI2bEABco2pwLD2JAKCz+SdKZdx8AOA6VYsT6U0EAB3NP50bDgCMk06PIgCEsvnnc5MBgLHy6VUEAJo/ABAC"
    "QADgsT8A8DoABIDKf/DHDQUAduHDQAJAtZf68bU/ANi5OoAlggSAKm/ywzp/ALB7nwA2CyIAVHp7X3b4AwBv7BjItsEEgAof7MPe/gDg"
    "Haqmc4AQAeCOR/pyqh8AeI+q7RwlTAAot/nXmXD9rGluFADwJlXj69DzCAA3N//a0mluDgDwPFXra9P7CACq+T8oHeCmAADfUDX/QQKA"
    "v5t/TWkDNwMA+I6q/TUJAP4NAMXcBADgW8UEAH82/ywmPwD4XhYBwF/NP4JJDwBwRBAA/NH8G0mXmfAAAIfqCY0IAN5u/n+WvmWyAwB+"
    "QvWGPxMAvNn8fyd9yiQHANyC6hG/IwB4b7nfFiY3AOAOtvhleaBfAsBUJjUAoIKmEgC80fyjmMyAfcYfXSbGHloiJhxnLOCKKAKA3c3/"
    "cekCExlwj2rimZtniYTlRaLXrNEiatJI0a1whOiYmy7apg8VLZOTRLMBieK5XgPEMz3iRP2OsaJueJR4/KWI65pHiCfbxIgGXXqJsKi+"
    "4vm4ePFSwiARnjpEtBsxTHTOyxA9xmeLmKmjRJ95+SK5dLIY+dd5oujYMsYf1aF6x+MEADub/2+lz5jEQOgVHV8mcnfOF0PenCL6zM0X"
    "XUZniJcGDRYNu/b+TyPX7AkZIhrF9BOthqWIiAnZIr5knEhbP0Pk71vMNUNFqR7yWwKAXc2/hrSGyQuEwPHlIvP92aL37DGiTVqqaBzb"
    "X9RtFeVao68K9ZRBPXXonJcuEl4pEqM/Wsh1xa2oXlKDAGBPAMhj0gLBk7NtruhbXBho+PU7xFrV7CuqUc/+omtBpkh6baIoOMBTAvxI"
    "HgHAjubfWipjwgJVN2rXgsAj8/ZZw119jO+WOs0jA98a9CjKFilvTRFjD5cwL/xN9ZTWBACzm/+fpLNMVqDy0jfMDPwCfjayr+8a/h2/"
    "J2gZKZoNTAx83zDmY14X+JTqLX8iAJjZ/O+XDjBJgYpTH+7FTBsV+LqeRl/BpwMtIkXLIcmBbwfGHeHJgM+oHnM/AcC8ADCPyQncWcGB"
    "JaL/orGBX7RqiR1Nver+0jZGdMhJE0PfmRpYCcH88oV5BACzmn8HJiVw+011kl+fJNqkp/54jT2CRn0roZYbZm+Zw5zzvg4EADOafy3p"
    "GyYk8HOj9ywMbJKjlr3RpPVp0idexC8dz2ZE3qV6Ti0CgPvr/dczGYGff8XfZUymdevzvUbtbNhv4Vgx/pOlzEvvWW/7/gC2B4AUJiFw"
    "03r97fNEx5Fpga/WacBmvR5QKwj4aNBzUggA7u3zf5kJCCwXWVvmiHaZwwJfqNNwzfVUp14idsZoUXhwCfPWGy7bfF6Arc3/V9IhJh/8"
    "LmPTLNF6WApf81umXvueInpyrijYz46DHqB60a8IAPoCwHQmHfwse+vcwFp0mqn9ywjV6Yi8GrDedAKAnuYfzmSDX6ktaSMm5PCO34Mf"
    "C6plmsxxq4UTAELb/B+WvmaiwY/UITVPd+9Dw/SwVkOHBHZnZL5bSfWmhwkAoQsAq5hk8JuRO+bzuN9H6raKFj2n57F00E6rCAChaf5t"
    "mVzwk3GyAcRMyWUtv0+FRfcTqW9P5V6wT1sCQHCb/4PSSSYW/EIdQcupfFDaZgwVeXuKuS/soXrVgwSA4AWAWUwq+OOgnsWBgk/jw09X"
    "C/RbWMg9Yo9ZBIDgNP8wqYwJBa9L3zCTj/xw+6cB6UPZRMgOqmeFEQCq1/zvkY4wmeBpx5eL3rPHsLQPFfJsRJzI3DyL+8Z8qnfdQwCo"
    "egAYwySCl+XvWyzCU4bQ2FC5lQLhUSJufgH3kPnGEACq1vwfk64wgeBVaetmiKe78cgfVdd6eErguxHuJ2OpHvYYAaByzf8uaSeTB159"
    "5K8OhOHgnp9oHimebNNbPNVloHg2KlU8FzdCPD8gVzTqlS6e7pEk6nfsL+q26sk4lbOLYPrGmdxX5lK97C4CQMUDQDKTBp585L93kWiZ"
    "nOS7xt6ga6JoljhGtM9bIKJnrxXxqz8SSeuOi9QPTor0nd+KrH0XRO6RMpH7ibijnENXReZH34vh278WKZs+F4PWHhFxy7eL7pNfE60z"
    "pweCw1/a+evJivp+RB03zD1mrGQCQMWa/++lc0wYeM2ID2YHzoX39Ln33QaJVhnTZDNeHWjKQzaeENn7L1WosQdbxu5/icR3DonY4o2i"
    "09gS8eLgAvFk616eHv82aamBDaS434yjetrvCQB3DgAlTBZ4zfB3p4t67WK8d75953jZ8KfKJrtBDNt62pVGXxnq6cGgNYcDTwuaDswT"
    "T4R775q8lDCIpYJmKiEA3L75N2CSwHOH+Kye6JntfOu17ytaDJsooue+K1Le/8L4hn8n2Qcui4Fv7hddJ6wQTfrliDotoj1xnZr0HiDG"
    "fLyQ+888DQgA5Tf/X0g7mCDwkgGLx1r/sV/dVrEiPH1q4L39yMPXrG/6t5O5598ies7awHcEXtgvQB0kxX1oFNXjfkEA+HkAiGJywEvU"
    "iW42f7j3wsA8Ebtwoxix97ynm/6tqA8UuxQtD3zXYO0rmk69ROb7s7kfzRJFAPhx879fOsXEgFeW+XUrtPMX5DNRKYEP+NQX9n5s+uU6"
    "UiYS3jog2mTPCixTtPEcgaFrp3FfmkP1uvsJAP8JAHlMCnjB+KPLRPsRw6xrEs0GFYjEtw/S7O/0zcD+S4FXBGpZo207Bw5+bSL3qDny"
    "CADXm39t6SITArYbe7jErjX+zSNF85QikfTeMZp7pVcTXAksL3w6Itma662+Rem/aCz3qhlUz6tNAPh0+UomA2yn1l6/lGjHu+I6svGH"
    "p00WQzb9nWZeTeqjyD4lW0RYjD1PfQgBxljp6wAw4fpRv0wEWK3o+DLRZniqBb8Ao0WbrJki9cOTNO8QfCfQb8UO0bh3phVPAngdYIww"
    "XwYA+RevIe1hAsB2nUdnGF/0X0wqFEO3fkWj1iBu+TbRoEuC8d8E8GGgEVQPrOHHANCDiw/bRU3ONbrQq4/V1C9TGrNe6myDToUlRm8s"
    "pFYHsETQCD18FQDkX/hu6SgXHjbrO7/A4MNhokXn8ctE1v6LNGQXpWz+XLwQP8rofQLYLMh1qhfe7acAEMtFh80SV04IfExnYlFvmjgm"
    "sIkNDdgcvZd8IOp3ijd2x0C2DXZdrC8CgPyL1pROcMFhq9S3p4onws3b218dzBO3bCsN11AjPj4vOowuDiy/NPHsAA4QcpXqiTX9EAD6"
    "cbFhq4xNaje4GAM38skXGbvP0mgtEF/6sajfsb+RpwhylLCr+nk6AMi/4D3Sl1xo2Ch353zxVMdYw5Z0RQWOth15pIzmapH0nd8a+W1A"
    "m7RU7nX3qN54j5cDwCAuMqzc4lf+Mnqh70DDHvkPFAls32v1JkLqGGLTXgn0mZvPPe+eQZ4MAPIvdp90mgsMG5l2uI/au98vj/zzjgox"
    "7rgQ+ce8+kpgr1GvBJ5oGSnSN87kvneH6pH3eTEApHJxYaOk1RMNe+S/2lOP/EfLBj/770K8cVqIHf8S4rPzQpy+JMTZK0JcuiZ+9Oda"
    "mRDnrgpx5rIQX14Q4sB3Qmz4pxAlXwpRdNzyVwIDzTk++pkecaLgwGLuf3ekeioAyL/QA9IZLixsM2rXAlGvfU8jirI6inbgG3s90fSn"
    "nxBi4xkhTl4U4mqZCNqff8vQsO/fQrxyUogxR+17JdA+b4ExIaD18BRqgDtUr3zASwEgk4sK6977H10mmvY3Y0tX9Yg4ad1xq5v+pE+F"
    "2CSb/j8uCS1/1NOD/d8JsfykXeOkPuo0JQTEzS+gFrgj0xMBwHn3/w0XFLbpMT7biCLcsPtgMfTDU9Y2/pdl49/5r+uP7936o14pvGJR"
    "EOi5YEPgdY8JZwZkbp5FPdDvGx3fAugIAPFcTNgmuXSyeLy5+80/LHZ44P2wjY1/7DEhtn0rxBUXG/9P/6hXDou+sGP8+q3aKeq26mnE"
    "ToFsEuSKeKsDgPwL3CUd50LCJnl/Kxb1O7i/3v/5AblixMfnrGz+8z4X4l9XhLF/VDDJs+AbgcR3Dom/tOvj+lxsmz6U2qCf6p132RwA"
    "2nMRYZOiY8tEswGJrhfc5ilFIvvAJSub/7tfu/u4v6J/vrggxMRPLThQaNPn4qku7u9B0W9hITVCv/Y2B4BtXEDYJM6AE/5aDp8U+CLc"
    "xua/+6yw6o9aUjjthPnjOmzbP1wPAer44Lw9xdQJvbZZGQDkf3hDLh5sok5Eq9fO3X3+myaMFjkHr1jZ/NV6fBv/fHtZiPHH7XgS4Pbr"
    "gLYZvApwQUMbA8CrXDjYpH3WMFeLa6Ne6WLE3vNWNv9XvxJW/1GvA8ZY8k2A2x8GqtMwqRdavWpVAJD/wX+UrnHhYItha6e5WlSf7pEk"
    "0nf9y8rmr349/3THPhv/bD5jz+oAN5cIhkX3C5yNQd3QRvXSP9oUAKZx0WDThj+Nerq3F3v9TgPE0K1fWbvOf8s3whN/Ll67vnTRln0C"
    "3AysPafnUTv0mmZFAJD/oQ9J57lgsEWvmaNd3d43ecOn1jZ/tf/+5WvCM3/eP8OOgRXaIKhVdOB4bOqHNqqnPmRDAGDbX9iz1//uBeLJ"
    "1tEunboWIwa+ud/q7X3f+ofw1B+1d4FN4+/m2QGthg6hhli+PXCwm/8vOfIXNlEHnrhVQKPnvmv9oT5//VZ47k++RYcIqeWibp4imPz6"
    "JOqI3qOCf2lyAGDjH1hjyBuT3VvrP2yiJ071O3bOewFAHU1s21HC6rAot44NHnekhHpi6cZAwQ4Aa7lAsOXDP7XHuVtf/I/4+LwnAsDX"
    "l7wXAJadtO86xJfuFY83j3RlPkdNGklN0WetkQFA/ofVlsq4QLDBgMVjXXvvn7z+U080f+WT770XAGacsPNadJ2wwrUdAgv2L6au6KF6"
    "bG0TA0AuFwe27Pf/bGRfd977z1nrmeavbPPYNwDqCIPRR+28FoHvAeJHuTOvJ+dSW/TJNSoAOKf+fcmFgQ0SXilypUi28Mh7/5uVnvZW"
    "ADhz2e7r4db3APXa9+TIYH2+DNYpgcEKAOFcFFjh+HLROLY/7/2DpOCYEOeveicAqJMMbb8m8aUfu/I9QOyM0dQXfcJNCgClXBDYIGn1"
    "RP2//mUxHrTmsOea/w3r/+mN5v/dVTvOA6iIDqOLtc/zpzr1YkWAPqVGBAD5H1JLusoFgQ1e6Kv/SNU22bM82/xvPAU454GnAGu/9s41"
    "UU+b6neK1z7X+8zNp87ooXpuLRMCADv/wQqpb09x4d1oX5G559+eDgDKoi+EuFZmb/M/8r0Qozx2TXov+UD7fG/YtTcHBVm0M2B1m38N"
    "6QQXAjZ4MWGQ/kNTFmzwfPO/4XVLPwg8eVGI/GPevCZurArot3As9UYP1XtruBkAmnERYIPh66ZrL4RN+maL3CNlvgkAysYzdjX/by4L"
    "MeG4d69HyubPRZ0W0dp3B1RLbak7WjRzMwAs4QLABi2HJGstguq8dptP+auOFaeuH61r+p8D3wlReMz716NTYYn28Bu/dDx1R48lrgQA"
    "+S++V/qOCwDT5Wyfp70Aqq+w/dj8b5j82fVH6yb+uVomxDv/8M+1yNp3QTTokqD36VefeGqPHqoH3+tGAGjH4MMGURNHai1+6utrL675"
    "ryy1o96ar4X43qAVAgflr/7pJ/x3LeKWb9MegrO3zKH+6NHOjQCwnIGHDRv/PN29j95tUWev9X3zv5k6XnfdP93dMEidWWDbKX/B1rh3"
    "ptb7IGJCDvVHj+VaA4D8F94nnWPgYbpha6dp/vU/QGQfuETjv8V+Aa9/db0ZXy3T84Hfh98IMevvjL3Sb8UO7UsCi47zMaAGqhffpzMA"
    "dGLQYYOOI9P0/uqZ9gbNpgLUx3erv7r+Id6/Lgen4V++JsTnF4T4gKZfviNlIixmmNb7Yeg7U6lDenTSGQBWMeAwndqWVB1Vqu1Y1PZ9"
    "Ax9c0Wwqb+yx65sJvfe1EB+dvb4xz9/PC/GPS0KcvSLEpWvXdxtUh/V8eVGI4+euh4et3wrxqgwS0054byOfUOhTskXvx7A5adQiPVZp"
    "CQDyX/Rr6QIDDk79+7FuE1fRZGD8kcFPR+hbEqsCOOcDaKF68q91BIBuDDZY+/9jT7bpLUZ89D1NBsaLLd6oNRirIE490qKbjgDwOgMN"
    "043+aKGo00Lfkaidxy+jucAKOYeuiAZdE7XdGyqIU5O0eD2kAUD+C34jXWKgYbres8doK3B1W8WKjN1naS6wRvSctRp3xYwUYz5eSF0K"
    "PdWbfxPKABDJIMMGz/UaoK3Atc2ZTVOBVbL3Xwq8tuKYYM+JDGUAWMkAw3Qjd8zX+o4z8e2DNBVYp032LG33SLOBidQmPVaGJADIf/Dd"
    "0lkGGKbrv2isvs1Oug/23Yl/8IaEtw5ou0+eaBkpxh5mNYAGqkffHYoA8AyDCxu0zRiqrbB1fXkFzQTWbgzUsNsgbfdKyltTqE96PBOK"
    "AJDHwMIGT3XqpW+nsw9P0UhgrS5Fy7XdKz2KsqlPeuSFIgDsZmBhuqwtc/Qdedo3myYCq6V+cFLb/fJ8HEcEa7I7qAFA/gMflsoYWJiu"
    "z7x8bQUtZt57NBFY77m4EXqWAzaPFAUHFlOnQk/16oeDGQBY/gcrtBqaoumjphiRuec7GgjYE6ASkl6bSJ0yaDlgRQNACQMK06mjR+u1"
    "66mlkDVPnUDzgCdk7vm3qNMiWs9HswWZ1Co9SoISAOQ/qIZ0hgGF6dI3ztT2S6bngg00D3hGk345Wu6bRj37U6v0UD27RjACQD0GEzaI"
    "nTFa39f/W7+iccAzuk5Yoe3eUed0UK+0qBeMAJDNQMIGLZKStBQwdZAKTQNeMvDN/ZwO6D3ZwQgA2xlIGP/+/9gy8WRrPe8xW4+YQdOA"
    "t84GOHBZPBEeo+fkzLx0apYe26sVAOQ/4AHpGgMJ4/f//+s8bb9gei1+n6YBz2k6ME/PuQADOBdAE9W7H6hOAGjKIMIGyaWTtQWAtB1n"
    "aBjwnO6TX9Ny/9TvGEvN0qdpdQJADgMIG/SePUZL8XomYgjNAp40aM1hbSE6fx8bAmmSU50AsJ4BhA3Ue0UdhavtyLk0C3hSzqGr4snW"
    "es7RSFs/g7qlx/oqBQDn+N9zDCBs8GKCnlPN+izdSrOAZ704uEDLfRRfMo66pce52x0PfLsAUJfBgy0adNbzyyXl/S9oFPCsTmNLtNxH"
    "ERNyqFv61K1KAEhk4GCDggNLtB1mknPwCo0CnhVbvFHLvdRqWAq1S5/EqgSAFQwcrNgCeIOeLYCf7pFEk4CnJb5zSM+WwDH9qF36rKhK"
    "ADjFwMEGA5eN11K0XkwqpEnA0zJ2/0vPaZrhUYHNu6hfWpyqVACQ/wePMGiwReTEkVqKVsf8RTQJeN5f2vXRcj+pzbuoX9o8UpkAEMGA"
    "wRZt0lK1FKyYee/RIOB5z8WN0HI/qc27qF/aRFQmAMxkwGCLJn3itRQsdWAKDQJe1zpzup4ltfPyqV/6zKxMANjLgMEWz0bEsQUwYNmW"
    "wDFTR1G/9NlboQAg/xdrSlcYMNjiqU6h3wOgbutYkXukjAYBz4tbvl1LAOgxPpv6pY/q6TUrEgAeZbBgEx3HAD8TyRkA8MmZAGuP6DkW"
    "eHQG9UuvRysSAHowULBF0fFlWopV496ZNAf4Qsqmz7XcU+1GDKOG6dWjIgGgkIGCLQoP6tkFUJ2VTnOAHwzf/rWWeyo8dQg1TK/CigSA"
    "dxgo2CLvb8VailXzlCKaA3wh86PvtdxTLyUMoobp9U5FAsBJBgq2yNk2V8/e5RnTaA7wzbHAOu6p5+PiqWF6nbxtAJD/Cw8xSLBJxqZZ"
    "et5XjppPc4Bv1G3VM+T3VFhUX2qYfg/dLgA0ZoBgk6Frp+n5YnncUhoDfKN+x/4hv6cadOlFDdOv8e0CQAIDBJskl07SEgDU5ig0BviF"
    "Ovky1PfUk21iqGH6JdwuAMxhgGCThFeKtASAqNlraAzwjUa90kN/XzWPEBOOU8M0m3O7ALCDAYJN+i8eqyUAxC7cSGOAbzw/IFfLfTX2"
    "0BLqmF47yg0A8v+jhnSeAYJNBi4bz0mAgKUnAo4/uow6ppfq8TXKCwB/YHBgm8GvTdSzb/m0UhoDfOPZqNAfsV03PIoa5o4/lBcAwhgY"
    "2Cb17SlaAkCXoldoDPCNp7oMDPk9Vb9jLDXMHWHlBYBoBga2SVs/Q0sA6DBmIY0BvvFkm96hP2CrRxw1zB3R5QWAbAYGtsn6cI6WANAm"
    "ayaNAf5wpEw83jwy5PfUc70GUMPckV1eAChmYGCbUbsWaAkALYZNpDHAF7L2XdByTzUbkEgNc0dxeQFgMwMD2+TvW6SnWA0qoDnAF9J3"
    "fqvlnmqZnEQNc8fm8gLA5wwMbDPuk6VailWTvtk0B/hC6gcntdxTbdOHUsPc8fmPAoD8H9SUrjEwsNETLUP/vjIsZhjNAb6QtO64lgDQ"
    "MTed+uUO1etr3hwAHmFQYKt67UN/cln9TgNoDvCF+NUfaQkA3QpHUL/c88jNAaAJAwJbPd29j5aCNeLj8zQIeF707LV6zteYNJL65Z4m"
    "NweAWAYEtmrUs7+WgqUejdIg4HXt8/SsrOk1azT1yz2xNweAUQwIbNV8cJKWgtW75EMaBDyvWeIYLfdTwvIi6pd7Rt0cABYzILBV14JM"
    "LQWr68sraRDwvAZdE7XcT5mbZ1G/3LP45gCwjgGBrfrOL9BSsMLTJtMg4GnZ+y9p2QWQo4Bdt+7mALCHAYG9BwJN1VKwGvVKp0nA04Zs"
    "PKHlXmrYtTe1y117bg4AbAIEe7cD3q3no6UnW/cK7JNOo4BXxS3fruVeemnQYGqXAZsB3QgA5xkQWOv4ctmco7UUrrQdZ2gU8Kzuk1fr"
    "OV57dAZ1y13nAwFA/j/uZTBguya9B2gpXAPf2EujgGe1ypim5T7qMzefuuW+e1UAqMVAwHZtM4bq2b1s4ioaBTyrYbdBWu6jIW9OoW65"
    "r5YKAI8yELBd1ORcLYXr+QG5NAp40rCtp7XcQ0ruzvnULfc9qgJAYwYCtlObiugoXE+0jA4slaJhwGtiizdouYfqtooSRceXUbfc11gF"
    "gA4MBGyXsWmWtl8v8aV8BwAvvv/Xs5y2cWx/apYZOqgAEMdAwHZqU5HHm+sJAJ3HL6NhwHOe6hyv5f5pk5ZKzTJDnAoAaQwEvOC5WD2H"
    "Aj0XN4KGAU9Jef8LbU/Qes8eQ70yQ5oKAOMZCHiBOl9cRwGr0yKKo4HhrSOA576rLQBkvj+bemWG8SoALGAg4AXJr0/SVsT6v7qbxgHP"
    "aDH0ZS33Tf0OsYGNu6hXRligAsAKBgJeUHBgifx1rucgkw75C2kc8ISRh6+Jeu378v7ff1aoAFDKQMArXug3UEshe6rzwEDhpIHAdvGr"
    "P9L25KxvcSF1yhylKgCsYSDgFRETcjQuB/yYBgLrhadP1XbP5GybS50yxxoVADYyEPAKXUcDK2rfdBoIbDZi73lRt1UsRwD700YVALYy"
    "EPCKcUdKRN3wKD07mrWOFVn7LtBIYO/ufws3agvM7bOGU6PMslUFgF0MBLzkxYRB2opar0WbaSSw1gsD8/S9MisZR30yyy4VAPYxEPCS"
    "mCm52opa04TRNBJYafj2r8XjzSO13Sujdi2gPpllnwoAnzAQ8JLh66ZrK2qqgKbtOENDgXW6T16t7T55NrIvtck8n6gAcIKBgJeMP7pM"
    "1O/QU1tx6zG1lIYC6zwTlaLtHulakEltMs8JFQC+YiDgNV3GZGorbk9HJLMnAKyS+PZBfU/JpPQNM6lL5vlKBYBvGQh4jSo4Ogtcn6Vb"
    "aCywRrNBBdrujbAoHv8b6lsVAM4xEPAiVXi0FbmYYSL3SBnNBcZLeu+Y1nAcM20U9chM51QAuMpAwJOrAWTh0Vno+q3cSYOB8ZqnFGn8"
    "SDZC5O6cTz0y01UCADxLLTtSBUhXsWvcJ5MGA6MN2fR3rUv/mg1MpBYZHgB4BQA2BQrWZierP6LRwNx9/9Mma70f+i8aSx0y/BUAHwHC"
    "swYsGae14D0/YCSNBkZK/fCkqKPx17/aklsd0U0dMvsjQJYBwrMKDy4RdVtFaw0BCW8fpOHAOG2y9K6MaZOeSg2yYBkgGwHB09pmDNVa"
    "+NT+6jQcmGTo1q9EnRZ6g3Dy65OoPxZsBMRWwPC0IW/ofe+pxC3bSuOBMV5MKtQ6/+t3jA3syEn9MX8rYA4DgqcVHVsmnu7eR2sBfKrz"
    "wMBZ6zQfuK3fih3aA3CP8dnUHksOA+I4YHhe3wUF2otgx/xFNCC4Kmv/RdGga6LWeV+3VZQYvWchdcd8geOAtzIQ8LpxR5aKBl16aS2E"
    "dVpEiSEbT9CI4JrO45dpD77qHA5qjhW2qgCwkYGAH/SePUZ7MWzSL4ctguHOsr8PToonWur98O+JlpGBDbioN1bYqALAGgYCfjD20BJR"
    "v0Os9hAQW7yRhgTtmibqD7wdR6ZRa+yxRgWAUgYCfhE9OVd7UazXoZ/I3PMdTQnaqFUouud5nRaRImf7POqMPUpVAFjBQMAPxn+yVDTr"
    "31c8/mIP7cWxVcZUGhO0yNh9VjzVOV77HG+XOYw6Y5cVKgAsYCDgh+b/Unw/8f8ahItHn+uovThefxWwgQaFkBp5pEw0G5Svf343jxBZ"
    "W+ZQa+yyQAWA8QwE/NL8lf9u2MqVpwB1W/UMnMZGo0KodJ/8mivhtvWwFGqNfcarAJDGQMAvzf+GR5t0cqVQPhuVKrL2XaBZIejUGRRq"
    "6akb8zpj0yzqjX3SVACIYyDgp+YfeArwdGtXCmXge4DMaTQshOC9/0BX5nPLIcnUGzvFqQDQgYGAn5r/D08BXPoWgKWBCP57/wJX5rFa"
    "95+9dS41x04dVABozEDAb80/oGEr8X/NurtSOOu2ihUpmz6ngSEI7/1XuxZkIybkUHPs1VgFgEcZCPiu+Tv+59l2rhVP9T3AiI++p4mh"
    "yga+sde19/7qgK2xh0uoO/Z6VAWAWgwE/Nj8b3js+S6uhYDn+48U2fsv0cxQaUnrjosn2/R2be4mvTaRumO3WioA3MtAwK/N/4cPAl1Y"
    "FnjDS0PGiZGHr9LUUGFDPzwl6nfs79qc5cM/T7j3v4QQKgScZzDgx+Z/w/82du+DQKVN1kwODUKFpO/8VjTsPti1uaqO+x25Yz61x27n"
    "Ve+/EQA+Z0Dg1+Z/w/816+ZqCOg0toQGh9sa8fE5ERY73NV5GjMll9pjv89vDgB7GBD4uflf/yCwrauFVYmc8RaNDuXKPnBJPD8g19X5"
    "+WxkXzFO3nfUH+vtuTkArGNA4Ofm/58PAju7GwKaR4reSz6g4eHHa/0PXxPNU4pcD6gpb02h/njDupsDwGIGBH5v/tfPCXD3g8Drx6pG"
    "EwLwg5yDV0TL4ZNcb/5tM4ZSf7xj8c0BYBQDAr83/x9eBYS1c73YqicBvA7AiL3nRdOE0a7PR7Xmv+DAYmqQd4y6OQDEMiCwQdvhg0La"
    "/N0+LKjcDwNZHeDPr/13/Us06pXu+hxU2/2mb5hJ/fGW2JsDQBMGBKYb/GqRlub/w6qApt2MCAFqiSD7BPhsnf/Wr8TTPZKMmH+9Z4+h"
    "/nhPk5sDwCMMCExWsH+RqNuik9YA4PYGQT/dLIgdA/0hecOnon6nAUbMu/CUIWLCceqPBz1ycwCoKV1jUGCq7oVpWpu/Ud8D3LRtMGcH"
    "eHxv/zf3u7q974/e+3frI/L38d7fg1Svr/lDAGAzIJjuhT59XAkAJn0PcOMAIU4R9Kboue+KJ1rGGDHP6rSIFGnrZlB7PLwJ0E8DwGYG"
    "Bqaq06yDawHApO8BbhwlHFu8kabpmd39zouWwyYaM7+U2BmjqTvetbm8AFDMwMBEo3bNd7X5m/Y9wA2tMqeJrH0XaKI2v+9f/6kxH/v9"
    "cNBPchLv/b2tuLwAkM3AwET5+xa5HgCufw/Q3qhCfeOVwJBNf6eZ2vjIf85aYx7539Cwa2+Rv3cRdcfbsssLANEMDExVr3VXI0KA26cG"
    "lv9KoKeILd5AU7XokX8Lwx75K/XaxYgRH8ym3nhfdHkBIIyBgamaJ/Q3IgCY9lHgj14JZEwVmXu+o8kabNCaw8Y98r9xxO/wd6dTa/wh"
    "rLwA8AcGBqbqPSvXmABw/dCgLkaGgHod+l3/QJDdA42Sueffok32rMAWz6bNGfXFf9LqidQZ//hDeQGghnSewYGJio4tE40iY8wKAS90"
    "NTIEKE365YghG0/QfN0mg1jPBRtEvfZ9jZ0rAxaPpcb4h+rxNX4WAJwQsIMBgqmyPpwt/jesjTkhoGEro5YH/vyXXZTomL8ocKAMzdid"
    "Hf2a9M02dn4oPafnUVv8ZcfNPf+nAWAOAwST9Zo50qinAP+tQkCz7kYX+ac6DxRxy7bSlDV+5NdhdHEggJk8L7oVjqCm+M+c2wWABAYI"
    "pouaOMKsEPB0a+NDgPLCwDyR8PZBmnSIZB+4JKJnrxX1O8UbPxfajxjGWn9/SrhdAGjMAIEQUIUQ8Ewb4zYKuuWZAgNGivjVH9G0g0Rt"
    "xhQx7Q1jDvCpyEY/448uo474U+PbBYCHGCDYYNqhxWJoWrxRIeB/nmlrTQhQGvfJFP1W7mTFQFUf9X/0veg2cZX4i8Ef+P3sVMnEQWLs"
    "4RJqiH89dMsA4ISAkwwSTDTx2DKxev1EcWRKsria1E2IxM5iVqd2xj0JsOF1wM3CYoaJPku3iJGHr9HYKyBj91nRefwyY07tq6g2w1PF"
    "uE+WUkv86+RP+315AeAdBgommbm/WOxcmCnODY8MNP2fMi4EWPJNwM+Of41IFj2mloq0HWdo9OUs50t8+6BomzM7cBiTbde28+gMUXSc"
    "x/4+905FAkAhAwUzGv9Csas4Q1xJ7lZu4zc6BBi+RPC2mkeKpgmjRa9Fm31/2NDQD0+Jri+vEA27D7bzWkpRk3OpJ1AKKxIAejBQcNOM"
    "A4sCv/gr0vhNDgFqnwCTNwuq0BaxrWNFq4xpIr70Y9+8IlDbKcfMe8/4Nfx33AdCBrm+8wuoKbihR0UCwKMMFNww/eAisWPRCHF5SPdK"
    "NX6jQ4DB2wZXZT+BDvkLRf9XdwfWunvql/7WrwI79jVPnWDcCX1V8UR4lEhcOYG6gps9WpEAUFO6wmBB5xf925dkiUspVW/8pocAUw8Q"
    "qs4ug8/FjQh8DBdfuldk779kVcNX3zn0Wvy+aD1ihmjQNdFT1+bJNjEi9e2p1BbcTPX0mncMAE4I2MuAQUfj31aSLRt/j6A0ftNDgIlH"
    "CQftF2fLaPH8gNzAsriBb+y9/iGhIcsLcw5eESnvfyH6LN0q2o6cK56JGOLZ6/BUx1iRsWkW9QU/tbe8Xn+rADCTAUOoTD28WGxdmi0u"
    "pga/8ZseAv4nrL1VewVU65do616iUa90EZ42WXR9eaXoXfKhSFp3PDSvD2TYUKFj4Jv7A+/v1RkILyYVBo7erWPgCXwh2emx70CRu3M+"
    "NQblmVmZABDBgCHYXj6+TGxalRfyxm96CAgsE7R1hUCQqF3z1P4D6kO7ZoMKRIthE0WbrJmiw5iFokvRK6LHtNJAI49duFFEzV4juk9+"
    "TXQet1S0GzU/8FFi85Qi0XRgnmjcO1M8Ezkk8LGin8dT7es/njX+uLWIygSARxgwBFPJthnidF6ctsZvegjw4ncB0K9e+54iafVEagzu"
    "5JEKBwAnBJxi0FD9x/1LxN/mp4myQV1caf6mh4D/CWvnm1cCCK6m/RPEqF0LqDO4k1O36vO3CwArGDhUxxvvThDfpUe72vhtCAG8EkDl"
    "NmqKED3GZ3OgDypqRVUCQCIDh6qY8/F8cWziIGMavw0hgFcCqNC3Ex1iRXLpZOoMKiOxKgGgLgOHyn7kt3nlqGpt5OP3EMArAdxKswGJ"
    "Iu9vxdQaVFbdqgSAu6VzDB4qYunWGeIfo/oY3fhtCQH/3bC1eOz5zjQ9XP/Qr12MiJtfIIqO8cgflaZ6+N2VDgBOCFjPAOJOa/r3zBvu"
    "+kd+XgsBgacBz7YV/9eMbwP8rH3WMDHm44XUGlTV+tv1+DsFgBwGELfy5toi8X1alHWN36YQ8MMOgrwW8JVGPfuLYWunUWdQXTnVCQBN"
    "GUD81ORPSsS+WUOtbvy2hQC1UsArhwrhdrsnRoteM0fzhT+CpWl1AsAD0jUGETcs2D1HfJ3b2zPN36YQcP21QDvxf8260yw9qPXwFDFq"
    "N+v6ETSqdz9Q5QDghIDtDCSUt98ZZ/wX/n4IAf+vYSvx6HMdaZoe8WxEnBjyBkv7EHTb79TfKxIAshlIf5t0tER8PGeYZxu/lSHAeS0Q"
    "2DuA7wPsbPyRfcWAxWN53I9QyQ5GAKjHQPrX/L/NtWp5n99CwPVlg84TAYKAFRrH9hcJrxSxrA+hVi8YAaCGdIbB9OdX/pdSeviq+dsa"
    "ApRm/fuK6Mm5gd3iaLRmHtcbOLjnOLUFIad6do1qBwAnBJQwoH565L80sLbfj43f1hDwUny/H46DHXtoieg9e4xo0KUXjdcALyYMEqlv"
    "T6G2QKeSivT2igaASAbUH+btmefasb2EgOo3/5uNO7JU9F1QIJ7u3odG7IKWQ5LF8HXTqStwQ2QwA8DDUhmD6m2l700QF1N70PgtCgG3"
    "av43U++a1VfmbTOGirqtomnOIaTCVtTEkSJn+zxqCtyievXDQQsATgjYzcB69xCf3QvSafaWhYCKNP+fKjy4RAxYMi7wWFodK0vTrr6/"
    "tI0RHUemXd+5j/f7cN/uivb1ygSAPAbWm0v8jk4aTJO3LARUpfn/1KhdC0TMtFEiLKovjbyS6rSIDDziV1/zjztSQi2BSfJCEQCeYWC9"
    "ZdqhxeKLwgE0d8tCQDCa/0+lb5gpuozJFPU79KTB38ZzvQYEPrAc/REH9MBYz4QiAKjjgc8yuN4wa1+x+Dq3D03dshAQiuZ/M7Upjfpw"
    "LWZKbuA1Qd3wKF83/Kc69Qp8O9F/0Vgxcsd8agdMp3r03UEPAE4IWMkAe2E//7nibGYMzdyyEBDq5l8e9Xg79e2pImJCjnih38DAo28v"
    "N/x67XqKVkNTRJ95+SJryxzqBWyzsjI9vbIBgOWAlivZNkOcHxZBE7csBLjR/MtTcGCJSH59kuhWOEI8F9vf+g8J1el7LZKSROyM0SJ9"
    "40xRdJzd+eD95X9VDQC/kS4xyHZatWmSpw/z8WoIMKX5l0dtOpSxaZZIWF4koibnBh6XN+k9INBYTWr0DTr3CrzS6JyXHniHn1w6WYz8"
    "6zy244WXqN78m5AFACcEvM5A23mS37XBXWnaloUAk5v/bR1fHjjaVr0+6Du/QHQtyBTNByeJRj37B9bK12vfUzzRMjivE9TeBupdvTpV"
    "r0mfeNEmLVVEThwpBi4bH/i4UT21oAbAB16vbD+vSgDoxkDbZdOqPBq1hSHA2uZfmW8M5N8vf9+iwJLErA/niLT1MwLb5g5+bWKggfdf"
    "PDaw1C65dJIYunZa4GlDzra5Iu9vxYE9DXhkD/ygm44A8GvpAoNthx2LMmnQmiTkJtP8AbhB9eRfhzwAOCFgFQNutonHlon9M1NpzJqo"
    "VRVq3KMmjqD5A9BtVVV6eVUDQCcG3OytfT+ZzO5+Om0ryf5h/KsTAmj+AKqgk84AcJ90jkE308dzhtGUNVOnKN58DXrNHCn+N6xNpZp/"
    "2+GDaP4AKkv14vu0BQAnBCxn4M2jfonSkPX6sqB/udci68PZolFkzB0bf90WncTgV4uYvwCqYnlV+3h1AkA7Bt4s617PpyG74N03Cm55"
    "TdQ6896zckXzhP6iXuuuPzT9Os06iBf69BHdC9NEwf5FzF8AVdXOjQBwr/Qdg2+GN96dIMoGdaEha/bvjBgx6WjFH9tfX/LGnvIAgkL1"
    "4Hu1BwAnBCzhArjvlQ+miqtJbPLjBvXUhTkIwCVLqtPDqxsAmnEB3LVoxyxxMbUHzdiCX/8AEGTN3AwANaQTXAR3zP1ovvg+LYpm7JL3"
    "Svn1D8A1qvfWcC0AOCEgkwuh34wDi8Q32bE0Yhd//U88xq9/AK7JrG7/DkYAqCVd5WLoM+XIEnFqTF8aMb/+AfiT6rm1XA8ATggo5YLo"
    "2+Xvs6IEmjC//gH4V2kwenewAkA4F0SP91fk0oRd//VfwFwE4KZwkwLAXdKXXJTQWrhzNsv9DDj0h1//AFykeu1dxgQAJwTkcmFCR53u"
    "dzovjibMr38A/pYbrL4dzABQWyrj4oQGe/zz6x+A76keW9u4AOCEgLVcoOBbsn2muDaYbX759Q/A59YGs2cHOwC05wIFl9pp7p8je9OA"
    "+fUPAO1NDgC/lE5zkYJn58JMGrAB3loznvkIwE2qt/7S2ADAzoDBtfzDaZzwZ4AT4xOYjwCs3/lPRwB4SDrPxar+bn/fZrHVr9uuJnUT"
    "8/bMY04CcJPqqQ8ZHwCcEDCNC1Y9uxek04ANsGVZDvMRgNumhaJXhyoA/FG6xkWrmhkHFgZ+edKA3XUmpxfH/QJwm+qlf7QmADgh4FUu"
    "HGv+bfbKB1OZjwDc9mqo+nQoA0BDLlzlTf6kRJwfFkEDdtn+manMRwAmaGhdAHBCwDYuXuWsXz2GBuwyFcCmH1zEfATgtm2h7NGhDgBs"
    "DFQJ6qhfvvx339o3C5mPADy38Y/uAKBOCTzORayYN96dQAN22ReFA5iLAEygeudd1gYAJwTEcyEr5tSYfjRhV9f8dxULds9hLgIwQXyo"
    "+7OOAHCf9A0X8867/tGE3bV9SRZzEYAJVM+8z/oAwPbAFXN00mCasIvUtxeTjpYwFwF4cttfNwPAA9IZLuqtt/29NrgrjdhFqzZNZi4C"
    "MIHqlQ94JgA4ISCVC1u+19e9TBN20a7iDOYhAFOk6urLOgOA+haAo4LLsWfecBqxS9SHlxOPsd0vACOc1vHuX3sAcELAIC7wz7H23x0X"
    "hkaIOR/PZw4CMMUgnT1ZdwC4R/qSi/wfs/YV04xdol69MAcBGEL1xns8GwCcENCPC/0fKzdPphnz3h8A+unux24EgJrSCS72dRteG01D"
    "1uxkvnrvv4z5B8AUqifW9HwAcEJALBf8uo/m8gGg/vf+C5h7AEwS60YvdisA3C0d5aIvF38fN5DGrNHq9RMpNgBMonrh3b4JAE4I6MGF"
    "V/v/96Uxa7JzYSbFBoBperjVh90MADWkPX6/+P8c2ZvmrMGXBf157w/ANKoH1vBdAHBCQJjfJ8C/RvSkQWt47z97L+/9ARgnzM0e7GoA"
    "cELASj9PgO/So2nSIfbaBt77AzDOSrf7rwkBoLZ0kVcACIW/Lh5BoQFgGtXzavs+ADghIM+/qwDiadQhcnhqMoUGgInyTOi9pgSA+6VT"
    "fpwIqknRrINPLa+cdJRDfgAYR/W6+wkAPw4BUX6cDGpLWhp2cJ3OixNTDy+h0AAwUZQpfdekAPALaYffJoPamIamHTxqVcXM/QspMgBM"
    "pHrcLwgA5YeABn6bEFOOLBFXk7rSvIPg3PBIMW/PPIoMAFM1MKnnGhUAnBBQ4rdJ8flYPgSsrksp3cWS7TMpMABMVWJavzUxAPxeOuen"
    "ifHh8pE08WpQT1BWbZpMgQFgKtXTfk8AqFgISPbT5FC/XGnkVffWmvEUGAAmSzax15oaAO6SdvppgpwfFkEzr4KNr+ZRXACYTPWyuwgA"
    "lQsBj0lX/DJJDk0bQkOvpB2L2OUPgNFUD3vM1D5rbABwQsAYv0yUZVum0dQrYf/MVIoLANONMbnHmh4A7pGO+GWyHJ00mOZeAZ9MTuJo"
    "XwCmU73rHgJA9Y8MLvPDhFmwe44oG9SFJn8bH80dLl4+TvMHYDTVs8JM76/GBwAnBMzyy8TZO3sojf4W1HJJCgsAC8yyobfaEgAelE76"
    "YeLM2lcsriR3o+Hf5NrgLmLtm4UUFQA2UL3qQQJAcENAW79MoO1Lsmj8jstDuotXN06iqACwRVtb+qo1AcAJAav8MIGmHl4szg2PYm//"
    "4ZGiZNsMCgoAW6yyqafaFgAelr72w0RaunW6uJrUzden+nGwDwCLqN70MAEgtCEg3C8TSm1x68fm/9XovhzpC8A24bb1U+sCgBMCpvtl"
    "Um1dmu2r5v9ZUULgiGSKCQCLTLexl9oaAH4lHWKbYO/t7scGPwAso3rRrwgAekPA49JlP0ywSUeXipP5/Tzb+C+m9hBr3mKZHwDrqB70"
    "uK191NoA4ISAFL9MNPVOXH0Y57Xmf2J8gpi9dwGFBICNUmzuobYHgBrSej+FAK88CVDr+9e9nk8BAWAr1XtqEADcDQG1pG/8MunU6wDb"
    "vwn4onAAS/wA2Ez1nFq290/rA4ATAjr4bQLauDpAbXG8aVUexQOA7Tp4oXd6IgA4IWCe3yah2ifAls2CTo3pFzjtkMIBwHLzvNI3vRQA"
    "7pcO+G0yqh0DTd42WH3h/8EruRzhC8ALVI+5nwBgZgj4k3TWb5NSnR3w18UjjDpF8GxmjNj4ah6b+gDwCtVb/uSlnumpAOCEgNZSmR8n"
    "qFpOpzbTKRvUxbXGfzovLvBqgl/8ADxE9ZTWXuuXngsATgjI8/NkXbhztvh0QoLWxv/phESx4v0pFAoAXpTnxV7p1QCg9gdY4/dJu3Lz"
    "FHFkSlLgPXyo1vLvmzVUFO+aTYEA4FVrbF/v76sA4ISA30qfMXmXBx7Hq48F1dLBk/n9q/WK4B+j+oidCzMD4ULtScD4AvAw1UN+69U+"
    "6dkAcNN5AReYxD827dBi8ca7E8TuBeniyJRk8fnYeHEmp5f4Lj06sN3w17m9A8v21Ml8f5ufLt4rzRevfDBVTD+4iPED4Beqdzzu5R7p"
    "6QDghIAoJjIAoJKivN4fPR8AnBAwlckMAKigqX7ojX4JADWlLUxqAMAdqF5RkwDgrRDwO+lTJjcA4BZUj/idX/qibwKAEwL+LH3LJAcA"
    "/ITqDX/2U0/0VQBwQkAj6TKTHQDgUD2hkd/6oe8CgBMCIpjwAABHhB97oS8DgBMCspj0AOB7WX7tg74NAE4IKGbyA4BvFfu5B/o9AKjl"
    "gRu4CQDAdzb4ZbkfAeDWIeBB6QA3AwD4hqr5D/q9//k+ADghoLZ0mpsCADxP1fra9D4CwM0hoI50lpsDADxL1fg69DwCQHkhoKF0jpsE"
    "ADxH1faG9DoCwO1CwPPSRW4WAPAMVdOfp8cRACoSAlpJV7hpAMB6qpa3orcRACoTArpI17h5AMBaqoZ3oacRAKoSAmKlMm4iALCOqt2x"
    "9DICQHVCQCI3EgBYJ5EeRgAIRghI52YCAGuk07sIAMEMAfncVABgvHx6FgGAEAAANH8QAHgdAAA89gcBoPofBrI6AADM+NqfD/4IANqX"
    "CLJPAAC4u86fpX4EANc2C2LHQABwZ4c/NvkhALi+bTBnBwCAPhfZ3pcAYNIBQpwiCAChp2otB/sQAIw7SvgsNycAhIyqsRzpSwAwMgTU"
    "kU5zkwJA0KnaWodeQwAwOQTUlg5wswJA0KiaWpseQwCwIQQ8KG3gpgWAalO19EF6CwHAphBQUyrm5gWAKlM1tCY9hQBgaxDI4iYGgErL"
    "oocQALwQAiKky9zQAHBHqlZG0DsIAF4KAY2kb7m5AeCWVI1sRM8gAHgxBPxZ+pSbHAB+RtXGP9MrCABeDgG/k7ZwswPAD1RN/B09ggDg"
    "lxUCU7npASBQC/nSnwDguyAQJV2gAADwIVX7ougFBAA/h4DHpc8oBgB8RNW8x+kBBABCwKfLfyutoSgA8AFV635L7ScA4D8hoIaUJ5VR"
    "IAB4UJlT42pQ8wkAKD8ItJ7AscIAvEXVtNbUeAIA7hwC/jSBEwUBeIOqZX+ithMAUPEQcL80j+IBwGKqht1PTScAoGpBoIP0DYUEgEVU"
    "zepADScAoPohoJa0nqICwAKqVtWidhMAENxVAikTOFUQgJkuOzWKr/wJAAjhxkGHKDYADHKIjX0IANATAn4lTafoADCAqkW/ojYTAKA3"
    "CIRLX1OAALhA1Z5wajEBAO6FgIelVRQjABqpmvMwNZgAADOCQFvpJIUJQAipGtOWmksAgHkh4EFpFucJAAjBPv6qtjxIrSUAwOwgECYd"
    "oWgBCAJVS8KorQQA2BMC7pHGSFcoYACq4IpTQ+6hphIAYGcQeEzaSTEDUAmqZjxGDSUAwP4QcJeULJ2jsAG4jXNOrbiL2kkAgLeCwO+l"
    "EoocgHKo2vB7aiUBAN4OAg2kHRQ8AE4taEBtJADAPyHgF1KUdIoCCPjSKacG/IKaSACAP4PA/VKedJGCCPjCReeev58aSAAAVBCoLa2k"
    "OAKepu7x2tQ8EABwq02E9lAoAU/Zw2Y+IACgIiGghtRDOkrhBKx21LmXa1DbQABAZYLA3VKsdIJCCljlhHPv3k0tAwEA1QkCNaV+0pcU"
    "VsBoXzr3ak1qFwgACPb5AoOk0xRawCinnXuTfftBAEBIg8B9Uqp0hsILuOqMcy/eR20CAQA6g8ADUqb0DYUY0Oob5957gFoEAgDcfiIQ"
    "Lx2jMAMhddy51/jFDwIAjDt1sL20jUINBNU2597ilD4QAGB8GGgovSpdo3gDVXLNuYcaUlNAAICNQeCP0jTpPAUdqJDzzj3zR2oICADw"
    "QhB4yPloiSWEwK2X8ql75CFqBggA8GIQ+KXzLnOtVEbRh8+VOfeCuid+SY0AAQB+OoEwlx0G4dMd+3I5mQ8EALB64NPl4VKpdJXmAI+6"
    "6szxcL7mBwEA+HkYqOW8B+UAInjpYB41p2txj4MAANw5CKgjiZtJS6TvaCKwzHfO3G3GUbwgAABVDwP3Su2k5dI5mgsMdc6Zo2qu3su9"
    "CwIAEPxthztJq6QLNB247IIzFzuxPS8IAIC+MPBrqZv0unSJZgRNLjlzTs29X3MvggAAuBsGfiNFSiulszQpBNlZZ26pOfYb7jkQAAAz"
    "w8Dd0jNSnrSbDYdQxQ16djtzSM2lu7m3QAAA7AsEDzu/3EqkMzQ33MIZZ46oufIw9w4IAID3lhfWk7Kl7ZxW6PvT9rY7c6Eey/VAAAD8"
    "FQgekJpKOdJ6lhl6fpneeudaq2v+APcACAAAbv5+oK6UKK2QTtE4rXXKuYaJzjXlPT5AAAAqFQoekSKkmdJe6QrN1ThXnGsz07lWjzB3"
    "AQIAEOxAUFN6VOohFUrvSCdpwtqcdMa80LkG6lrUZG4CBADArWDwkNRYSpDmSDuk8zTsKjvvjOEcZ0zV2D7EXAMIAIAtqw7+IIVJ0c4X"
    "58XSZulzn69CuOaMwWZnTLKdMQpzxoyv8gECAODp1wnqG4MmUqw0SlosrZP2OA3yvKW/3j93/g7rnL/TKOfv2MT5O/PYHiAAALhDUFAn"
    "ItZy3nerR+EdpDgpTRovLXC+eC+V1kgbpa3SLmmf9IlzLv1X0rfOkrirjnPO/+wr53/nE+f/Zpfzz9jo/DNLnX/HAuffmeb8N3Rw/pse"
    "df4bOQkPsMD/B5R5vfrcRB0EAAAAAElFTkSuQmCC")
GITHUB_ICON_DATA = (
    "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"
    "i7+t2nCZAAAAAElFTkSuQmCC")
INFO_ICON_DATA = (
    "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"
    "VORK5CYII=")


def guid():
    def run(cmd):
        try:
            return subprocess.run(cmd, shell=True, capture_output=True, check=True, encoding="utf-8").stdout.strip()
        except:
            return None

    if sys.platform == 'darwin':
        return run("ioreg -d2 -c IOPlatformExpertDevice | awk -F\\\" '/IOPlatformUUID/{print $(NF-1)}'")

    if sys.platform == 'win32' or sys.platform == 'cygwin' or sys.platform == 'msys':
        return run('wmic csproduct get uuid').split('\n')[2].strip()

    if sys.platform.startswith('linux'):
        return run('cat /var/lib/dbus/machine-id') or run('cat /etc/machine-id')

    if sys.platform.startswith('openbsd') or sys.platform.startswith('freebsd'):
        return run('cat /etc/hostid') or run('kenv -q smbios.system.uuid')


def encrypt(super_key: str | bytes | list[str | bytes],
            source: str | bytes,
            encode: bool = True,
            layers: int = 1):
    try:
        if isinstance(super_key, list):
            if len(super_key) >= 2 and layers > 1:
                if layers % 2 == 1:
                    key = super_key[0]
                else:
                    key = super_key[1]
            else:
                key = super_key[0]
        else:
            key = super_key

        if encode:
            __key = key.encode("utf-8")  # key must be bytes
            source = source.encode("utf-8")
        else:
            __key = key

        __key = SHA256.new(__key).digest()  # use SHA-256 over our key to get a proper-sized AES key
        IV = Random.new().read(AES.block_size)  # generate IV
        encryptor = AES.new(__key, AES.MODE_CBC, IV)
        padding = AES.block_size - len(source) % AES.block_size  # calculate needed padding
        source += bytes([padding]) * padding  # Python 2.x: source += chr(padding) * padding
        data = IV + encryptor.encrypt(source)  # store the IV at the beginning and encrypt
        data = base64.b64encode(data).decode("utf-8") if encode else base64.b64encode(data)
        if layers > 1:
            for layer in range(layers - 1, 0, -1):
                if isinstance(super_key, list):
                    if len(super_key) >= 2 and layers > 1:
                        if layer % 2 == 1:
                            key = super_key[0]
                        else:
                            key = super_key[1]
                    else:
                        key = super_key[0]

                data = encrypt(key, data, encode=encode)

        return data
    except:
        return None


def decrypt(super_key: str | bytes | list[str | bytes],
            source: str | bytes,
            decode: bool = True,
            layers: int = 1):
    try:
        if isinstance(super_key, list):
            if len(super_key) >= 2 and layers > 1:
                if layers % 2 == 0:
                    key = super_key[0]
                else:
                    key = super_key[1]
            else:
                key = super_key[0]
        else:
            key = super_key

        if decode:
            __key = key.encode("utf-8")  # key must be bytes
            source = base64.b64decode(source.encode("utf-8"))
        else:
            __key = key
            source = base64.b64decode(source)

        __key = SHA256.new(__key).digest()  # use SHA-256 over our key to get a proper-sized AES key
        IV = source[:AES.block_size]  # extract the IV from the beginning
        decryptor = AES.new(__key, AES.MODE_CBC, IV)
        data = decryptor.decrypt(source[AES.block_size:])  # decrypt
        padding = data[-1]  # pick the padding value from the end; Python 2.x: ord(data[-1])
        if data[-padding:] != bytes([padding]) * padding:  # Python 2.x: chr(padding) * padding
            return None  # if the padding is incorrect, this is not the correct key
        data = data[:-padding].decode("utf-8") if decode else data[:-padding]
        if layers > 1:
            for layer in range(layers - 1, 0, -1):
                if isinstance(super_key, list):
                    if len(super_key) >= 2 and layers > 1:
                        if layer % 2 == 0:
                            key = super_key[0]
                        else:
                            key = super_key[1]
                    else:
                        key = super_key[0]

                data = decrypt(key, data, decode=decode)

        return data
    except:
        return None


# Modify the thread class to propagate exceptions
class PropagatingThread(threading.Thread):
    # add self.exc and self.ret to __init__ to avoid PyCharm warnings
    def __init__(self, *args, **kwargs):
        super(PropagatingThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()
        self.exc = None
        self.ret = None

    def run(self):
        self.exc = None
        try:
            if hasattr(self, '_Thread__target'):
                # Thread uses name mangling prior to Python 3.
                self.ret = self._Thread__target(*self._Thread__args, **self._Thread__kwargs)  # type: ignore
            else:
                self.ret = self._target(*self._args, **self._kwargs)  # type: ignore
        except BaseException as e:
            self.exc = e

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()

    def join(self, timeout=None):
        super(PropagatingThread, self).join(timeout)
        if self.exc:
            raise self.exc
        return self.ret


class VerticalScrolledFrame(ttk.Frame):
    def __init__(self, parent, *args, **kw):
        ttk.Frame.__init__(self, parent, *args, **kw)

        # Create a canvas object and a vertical scrollbar for scrolling it.
        vscrollbar = ttk.Scrollbar(self, orient=constants.VERTICAL)
        vscrollbar.pack(fill="y", side=constants.RIGHT, expand=constants.FALSE)
        self.canvas = Canvas(self, bd=0, highlightthickness=0,
                             width=200, height=300,
                             yscrollcommand=vscrollbar.set)
        self.canvas.pack(side=constants.LEFT, fill=constants.BOTH, expand=constants.TRUE)
        vscrollbar.config(command=self.canvas.yview)

        # Reset the view
        self.canvas.xview_moveto(0)
        self.canvas.yview_moveto(0)

        # Create a frame inside the canvas which will be scrolled with it.
        self.interior = ttk.Frame(self.canvas)
        self.interior.bind('<Configure>', self._configure_interior)
        self.canvas.bind('<Configure>', self._configure_canvas)
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        self.interior_id = self.canvas.create_window(0, 0, window=self.interior, anchor=constants.NW)

    def _on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    def _configure_interior(self, event):
        # Update the scrollbars to match the size of the inner frame.
        size = (self.interior.winfo_reqwidth(), self.interior.winfo_reqheight())
        self.canvas.config(scrollregion=(0, 0, size[0], size[1]))
        if self.interior.winfo_reqwidth() != self.canvas.winfo_width():
            # Update the canvas's width to fit the inner frame.
            self.canvas.config(width=self.interior.winfo_reqwidth())
        _ = event  # Avoid PyCharm warning

    def _configure_canvas(self, event):
        if self.interior.winfo_reqwidth() != self.canvas.winfo_width():
            # Update the inner frame's width to fill the canvas.
            self.canvas.itemconfigure(self.interior_id, width=self.canvas.winfo_width())
        _ = event  # Avoid PyCharm warning


class IPTranslator:
    def __init__(self, **kwargs):
        self.__DEBUG = True
        self.parent = None

        self.__uuid: str | bytes | list = [guid(), os.getlogin()]  # Unique ID for encryption
        self.__enc_layers: int = 10  # Number of nested encryption layers (Recommended Maximum: 10)

        self.input_file: str = kwargs.get("input_file", "")
        self.inputs: dict = {}  # {sheet1: [[subnet1, ipaddress(subnet1), type1], ...etc], ...etc}
        self.input_invalids: list = []  # [[sheet1, subnet1, row1], ... etc]
        self.inputs_no: int = 0  # Number of valid subnets in the input file
        self.all_inputs_no: int = 0  # Number of all records in the input file

        self.ref_file: str = kwargs.get("ref_file", "")
        self.refs: dict = {}  # {sheet1: [[tenant1, name1, subnet1, ipaddress(subnet1), type1], ...etc], ...etc}
        self.ref_invalids: list = []  # [[sheet1, subnet1, row1], ... etc]
        self.ref_no: int = 0  # Number of valid subnets in the reference file

        self.settings_file: str = kwargs.get("settings_file", 'settings.cfg')

        self.ssh_pan: SSHClient | None = kwargs.get("ssh_pan", None)
        self.pan_ip: str = kwargs.get("pan_ip", "")
        self.pan_username: str = kwargs.get("pan_username", "")
        self.pan_password: str = kwargs.get("pan_password", "")
        self.pan_vsys: str = kwargs.get("pan_vsys", "")
        self.pan_addresses: list = []  # [[vsys1, name1, subnet1, ipaddress(subnet1), type1], ...etc]

        self.forti_api: FortiGateAPI | None = kwargs.get("forti_api", None)
        self.forti_ip: str = kwargs.get("forti_ip", "")
        self.forti_port: int = kwargs.get("forti_port", 443)
        self.forti_username: str = kwargs.get("forti_username", "")
        self.forti_password: str = kwargs.get("forti_password", "")
        self.forti_vdom: str = kwargs.get("forti_vdom", "")
        self.forti_addresses: list = []  # [[vdom1, name1, subnet1, ipaddress(subnet1), type1], ...etc]

        self.ssh_apic: SSHClient | None = kwargs.get("ssh_apic", None)
        self.apic_ip: str = kwargs.get("apic_ip", "")
        self.apic_username: str = kwargs.get("apic_username", "")
        self.apic_password: str = kwargs.get("apic_password", "")
        self.apic_class: str = kwargs.get("apic_class", "fvSubnet")
        self.apic_addresses: list = []  # [[tenant1, name1, subnet1, ipaddress(subnet1), type1], ...etc]

        self.dns_resolver: dns.resolver.Resolver | None = kwargs.get("dns_resolver", None)
        self.dns_servers: list | Sequence[str | Nameserver] = list(
            kwargs.get("dns_servers", dns.resolver.Resolver().nameservers))
        if len(self.dns_servers) < 4:
            self.dns_servers.extend([""] * (4 - len(self.dns_servers)))
        self.resolvers: list = []

        self.output_file: str = kwargs.get("output_file", "")
        self.outputs: dict = {}

        self.separators: list = kwargs.get("separators", [",", ";", "\r\n", "\n\r", "\n", "\r"])

        self.__stop = False

    #######################################################
    def clear_var(self) -> None:
        self.inputs = {}
        self.input_invalids = []
        self.inputs_no = 0

        # self.refs = {}
        # self.ref_invalids = []
        # self.ref_no = 0

        # self.pan_addresses = []
        # self.forti_addresses = []
        # self.apic_addresses = []

        self.outputs = {}

    def save_credentials(self, app: str = "") -> bool:
        __pan_ip = self.pan_ip if self.pan_ip else "PLACEHOLDER"
        __pan_username = self.pan_username if self.pan_username else "PLACEHOLDER"
        __pan_password = self.pan_password if self.pan_password else "PLACEHOLDER"
        __pan_vsys = self.pan_vsys if self.pan_vsys else "PLACEHOLDER"

        __forti_ip = self.forti_ip if self.forti_ip else "PLACEHOLDER"
        __forti_port = self.forti_port if self.forti_port else 443
        __forti_username = self.forti_username if self.forti_username else "PLACEHOLDER"
        __forti_password = self.forti_password if self.forti_password else "PLACEHOLDER"
        __forti_vdom = self.forti_vdom if self.forti_vdom else "PLACEHOLDER"

        __apic_ip = self.apic_ip if self.apic_ip else "PLACEHOLDER"
        __apic_username = self.apic_username if self.apic_username else "PLACEHOLDER"
        __apic_password = self.apic_password if self.apic_password else "PLACEHOLDER"
        __apic_class = self.apic_class if self.apic_class else "PLACEHOLDER"

        __dns_servers = self.dns_servers if self.dns_servers else ["PLACEHOLDER", "PLACEHOLDER",
                                                                   "PLACEHOLDER", "PLACEHOLDER"]

        pan_text = f"pan\n{"\n".join([__pan_ip, __pan_username, __pan_password, __pan_vsys])}"
        forti_text = f"forti\n{"\n".join([__forti_ip, str(__forti_port),
                                          __forti_username, __forti_password, __forti_vdom])}"
        apic_text = f"apic\n{"\n".join([__apic_ip, __apic_username, __apic_password, __apic_class])}"
        dns_text = f"dns\n{"\n".join(__dns_servers)}"

        enc_pan = encrypt(self.__uuid, pan_text, encode=True, layers=self.__enc_layers)
        enc_forti = encrypt(self.__uuid, forti_text, encode=True, layers=self.__enc_layers)
        enc_apic = encrypt(self.__uuid, apic_text, encode=True, layers=self.__enc_layers)
        enc_dns = encrypt(self.__uuid, dns_text, encode=True, layers=self.__enc_layers)

        if not app:
            if not all([enc_pan, enc_forti, enc_apic, enc_dns]):
                return False

            enc_text = f"{"\n".join([enc_pan, enc_forti, enc_apic, enc_dns])}"
            with open(self.settings_file, 'w') as f:
                f.write(enc_text)
            return True

        else:
            index, enc_text = None, None

            if app == 'pan':
                if not enc_pan:
                    return False
                index, enc_text = 0, enc_pan

            elif app == 'forti':
                if not enc_forti:
                    return False
                index, enc_text = 1, enc_forti

            elif app == 'apic':
                if not enc_apic:
                    return False
                index, enc_text = 2, enc_apic

            elif app == 'dns':
                if not enc_dns:
                    return False
                index, enc_text = 3, enc_dns

            try:
                with open(self.settings_file, 'r') as f:
                    lines = f.readlines()
            except:
                lines = []

            if len(lines) < index + 1:
                lines += ["DO NOT DELETE THIS LINE (PLACEHOLDER)\n" for _ in range(index - len(lines) + 1)]

            if index is not None and enc_text:
                lines[index] = enc_text + "\n"

            with open(self.settings_file, 'w') as f:
                f.write("".join(lines))
                return True

    def import_credentials(self, app: str = '') -> list[bool]:
        __imported = [False for _ in range(4)]
        filename = 'settings.cfg'

        if os.path.isfile(self.settings_file) and os.path.getsize(self.settings_file) > 0:
            with open(self.settings_file, 'r') as f:
                enc_data = [x.replace("\n", "").strip() for x in f.readlines() if x.strip()]

            dec_data = {}
            for i, enc_line in enumerate(enc_data):
                dec_line = decrypt(self.__uuid, enc_line, decode=True, layers=self.__enc_layers)

                if dec_line:
                    dec_line = dec_line.split("\n")
                    if ((dec_line[0] in ["pan", "apic"] and len(dec_line) == 5)
                            or (dec_line[0] == "forti" and len(dec_line) == 6)
                            or dec_line[0] == "dns"):
                        for j, item in enumerate(dec_line[1:]):
                            if item == "PLACEHOLDER":
                                dec_line[j + 1] = ""

                        dec_data[dec_line[0]] = dec_line[1:]
                        continue

                enc_data[i] = "DO NOT DELETE THIS LINE (PLACEHOLDER)"

                with open(self.settings_file, 'w') as f:
                    f.write("\n".join(enc_data))

            if not dec_data:
                __new_filename = f'{datetime.now().strftime("%Y%m%d-%H%M%S")}_{self.settings_file}.bak'
                os.rename(self.settings_file, __new_filename)
                self.parent.log.set(f"ERROR - Corrupted settings file renamed ({__new_filename}).")
                return __imported

            if app in ['pan', ''] and len(dec_data.get('pan', [])) == 4:
                self.pan_ip = dec_data['pan'][0]
                self.pan_username = dec_data['pan'][1]
                self.pan_password = dec_data['pan'][2]
                self.pan_vsys = dec_data['pan'][3]
                self.parent.log.set("INFO - Palo Alto credentials imported.")
                __imported[0] = True

            if app in ['forti', ''] and len(dec_data.get('forti', [])) == 5:
                self.forti_ip = dec_data['forti'][0]
                try:
                    self.forti_port = int(dec_data['forti'][1])
                except:
                    self.forti_port = dec_data['forti'][1]
                self.forti_username = dec_data['forti'][2]
                self.forti_password = dec_data['forti'][3]
                self.forti_vdom = dec_data['forti'][4]
                self.parent.log.set("INFO - FortiGate credentials imported.")
                __imported[1] = True

            if app in ['apic', ''] and len(dec_data.get('apic', [])) == 4:
                self.apic_ip = dec_data['apic'][0]
                self.apic_username = dec_data['apic'][1]
                self.apic_password = dec_data['apic'][2]
                self.apic_class = dec_data['apic'][3]
                self.parent.log.set("INFO - APIC credentials imported.")
                __imported[2] = True

            if app in ['dns', ''] and len(dec_data.get('dns', [])) == 4:
                self.dns_servers = dec_data['dns']
                self.parent.log.set("INFO - DNS servers imported.")
                __imported[3] = True

        return __imported

    #######################################################

    def check_input_file(self, widget="") -> bool:
        start_flag = self.parent.start_status()

        if "input_entry" in widget:
            return False

        if (self.input_file == self.parent.input_row.entry.get().strip()
                and start_flag
                and self.inputs_no):
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The input is valid.", "green", "arrow")
            return True

        self.input_file = self.parent.input_row.entry.get().strip()
        input_type = self.get_type(self.input_file)

        if not self.input_file:
            self.input_file = ""
            self.inputs = {}
            self.input_invalids = []
            self.inputs_no = 0
            self.all_inputs_no = 0

            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message(f"Please enter the input file.", "red", "arrow")
            if start_flag:
                self.parent.log.set("ERROR - Input file is not selected.")
            return False

        elif input_type != "Invalid":
            if input_type != "List":
                self.inputs = {"Result": [[self.input_file,
                                           self.convert2ipaddress(self.input_file, input_type),
                                           input_type]]}
                self.inputs_no = 1
                self.input_invalids = []

            elif any(sep in self.input_file for sep in self.separators):
                self.inputs = {}
                self.inputs_no = 0
                self.input_invalids = []

                sep = [sep for sep in self.separators if sep in self.input_file][0]
                self.input_file = self.input_file.split(sep)

                for i, subnet in enumerate(self.input_file):
                    subnet = subnet.strip()
                    subnet_type = self.get_type(subnet)
                    if subnet_type == "Invalid":
                        self.input_invalids.append(["Input", subnet, i + 1])
                        continue
                    self.inputs_no += 1
                    self.inputs.setdefault("Result", []).append([subnet,
                                                                 self.convert2ipaddress(subnet, subnet_type),
                                                                 subnet_type])

            self.all_inputs_no = self.inputs_no + len(self.input_invalids)
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The input is valid.", "green", "arrow")
            if start_flag:
                self.parent.log.set(f"INFO - Input file is valid ({self.input_file}).")
            return True

        if not isinstance(self.input_file, str):
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Invalid input file.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Invalid input file {self.input_file}.")
            return False

        excel_ext = (".xls", ".xlsx", ".xlsm", ".xlsb", ".odf", ".ods", ".odt")
        csv_ext = (".csv",)
        text_ext = (".txt",)

        data = {}
        self.inputs = {}
        self.input_invalids = []
        self.inputs_no = 0

        if not (self.input_file.lower().endswith(excel_ext)
                or self.input_file.lower().endswith(csv_ext)
                or self.input_file.lower().endswith(text_ext)):
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Invalid input file extension.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Invalid input file extension {self.input_file}.")
            return False

        elif not os.path.isfile(self.input_file):
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Input file not found.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Input file not found {self.input_file}.")
            return False

        elif os.stat(self.input_file).st_size == 0:
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Empty input file.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Empty input file {self.input_file}.")
            return False

        elif self.input_file.lower().endswith(excel_ext):
            for engine in [None, "xlrd", "openpyxl", "odf", "pyxlsb"]:
                try:
                    with pd.ExcelFile(self.input_file, engine=engine) as f:
                        sheet_names = f.sheet_names
                    break
                except:
                    sheet_names = []

            if not sheet_names:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No sheets in input file workbook.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No sheets in input file workbook {self.input_file}.")
                return False

            for sheet in sheet_names:
                df = pd.read_excel(self.input_file, sheet_name=sheet, engine=engine)

                if "Subnet" in df.columns:
                    data[sheet] = df["Subnet"].tolist()
                elif "subnet" in df.columns:
                    data[sheet] = df["subnet"].tolist()

            if not data:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No subnets in the input file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No subnets in the input file {self.input_file}.")
                return False

            for sheet in data.keys():
                for i, subnet in enumerate(data[sheet]):
                    subnet = str(subnet).strip()
                    subnet_type = self.get_type(subnet)

                    if subnet == "nan":
                        subnet = ""

                    if subnet_type == "Invalid":
                        if not subnet:
                            self.input_invalids.append([sheet, "Empty", i + 2])
                        else:
                            self.input_invalids.append([sheet, subnet, i + 2])
                        # continue
                        self.inputs.setdefault(sheet, []).append([subnet,
                                                                  subnet,
                                                                  subnet_type])
                    else:
                        self.inputs_no += 1
                        self.inputs.setdefault(sheet, []).append([subnet,
                                                                  self.convert2ipaddress(subnet, subnet_type),
                                                                  subnet_type])

            if not self.inputs_no:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No valid subnets in the input file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No valid subnets in the input file {self.input_file}.")
                return False

            self.all_inputs_no = self.inputs_no + len(self.input_invalids)
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The input is valid ({self.inputs_no} Subnets).", "green", "arrow")
            self.parent.log.set(f"INFO - Input file is valid ({self.input_file}).")
            return True

        elif self.input_file.lower().endswith(csv_ext):
            try:
                df = pd.read_csv(self.input_file)
            except:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("Invalid CSV file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - Invalid CSV file {self.input_file}.")
                return False

            if "Subnet" in df.columns:
                subnets = df["Subnet"].tolist()
            elif "subnet" in df.columns:
                subnets = df["subnet"].tolist()
            else:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No subnets in the input file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No subnets in the input file {self.input_file}.")
                return False

            for i, subnet in enumerate(subnets):
                subnet = str(subnet).strip()
                subnet_type = self.get_type(subnet)

                if subnet_type == "Invalid":
                    if subnet == "nan":
                        self.input_invalids.append(["CSV", "Empty", i + 2])
                        subnet = ""
                    else:
                        self.input_invalids.append(["CSV", subnet, i + 2])
                    # continue
                    self.inputs.setdefault("CSV", []).append([subnet,
                                                              subnet,
                                                              subnet_type])
                else:
                    self.inputs_no += 1
                    self.inputs.setdefault("CSV", []).append([subnet,
                                                              self.convert2ipaddress(subnet, subnet_type),
                                                              subnet_type])

            if not self.inputs_no:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No valid subnets in the input file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No valid subnets in the input file {self.input_file}.")
                return False

            self.all_inputs_no = self.inputs_no + len(self.input_invalids)
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The input is valid ({self.inputs_no} Subnets).", "green", "arrow")
            self.parent.log.set(f"INFO - Input file is valid ({self.input_file}).")
            return True

        elif self.input_file.lower().endswith(text_ext):
            try:
                with open(self.input_file, "r") as f:
                    data = f.readlines()
            except:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("Invalid text file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - Invalid text file {self.input_file}.")
                return False

            if not data:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No subnets in the input file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No subnets in the input file {self.input_file}.")
                return False

            for i, subnet in enumerate(data):
                subnet = str(subnet).strip()
                subnet_type = self.get_type(subnet)

                if subnet_type == "Invalid":
                    if subnet == "nan":
                        self.input_invalids.append(["Text", "Empty", i + 1])
                        subnet = ""
                    else:
                        self.input_invalids.append(["Text", subnet, i + 1])
                    # continue
                    self.inputs.setdefault("Text", []).append([subnet,
                                                               subnet,
                                                               subnet_type])
                else:
                    self.inputs_no += 1
                    self.inputs.setdefault("Text", []).append([subnet,
                                                               self.convert2ipaddress(subnet, subnet_type),
                                                               subnet_type])

            if not self.inputs_no:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No valid subnets in the input file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No valid subnets in the input file {self.input_file}.")
                return False

            self.all_inputs_no = self.inputs_no + len(self.input_invalids)
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The input is valid ({self.inputs_no} Subnets).", "green", "arrow")
            self.parent.log.set(f"INFO - Input file is valid ({self.input_file}).")
            return True

    #######################################################

    def check_ref_file(self, widget="") -> bool:
        start_flag = self.parent.start_status()
        ref_checkbox = self.parent.ref_row.checkbox_var.get()

        if "ref_entry" in widget:
            return False

        if (self.ref_file == self.parent.ref_row.entry.get().strip()
                and start_flag
                and self.ref_no):
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The reference is valid.", "green", "arrow")
            return True

        self.ref_file = self.parent.ref_row.entry.get().strip()

        # Check if the reference file is selected
        if not self.ref_file:
            self.ref_file = ""
            self.refs = {}
            self.ref_invalids = []
            self.ref_no = 0

            if ref_checkbox:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("Please enter the reference file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set("ERROR - Reference file is not selected.")
            return False

        if not isinstance(self.ref_file, str):
            if ref_checkbox:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("Invalid reference file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - Invalid reference file {self.ref_file}.")
            return False

        excel_ext = (".xls", ".xlsx", ".xlsm", ".xlsb", ".odf", ".ods", ".odt")
        csv_ext = (".csv",)

        tenant_col = ("Tenant", "tenant", "Tenant / Vsys", "Zone", "zone", "vlan", "VLAN")
        object_col = ("Address object", "address object", "Address Object", "address Object", "Name",
                      "name", "Object Name", "object name", "Object name", "object Name")
        subnet_col = ("Subnet", "subnet", "IP", "ip", "IP Address", "ip address", "IP address",
                      "ip Address", "IP/Subnet", "ip/subnet", "IP/subnet", "ip/Subnet")

        data = {}
        self.refs = {}
        self.ref_invalids = []
        self.ref_no = 0

        if not (self.ref_file.lower().endswith(excel_ext)
                or self.ref_file.lower().endswith(csv_ext)):
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Invalid reference file extension.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Invalid reference file extension {self.ref_file}.")
            return False

        elif not os.path.isfile(self.ref_file):
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Reference file not found.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Reference file not found {self.ref_file}.")
            return False

        elif os.stat(self.ref_file).st_size == 0:
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message("Empty reference file.", "red", "arrow")
            if start_flag:
                self.parent.log.set(f"ERROR - Empty reference file {self.ref_file}.")
            return False

        elif self.ref_file.lower().endswith(excel_ext):
            for engine in [None, "xlrd", "openpyxl", "odf", "pyxlsb"]:
                try:
                    with pd.ExcelFile(self.ref_file, engine=engine) as f:
                        sheet_names = f.sheet_names
                    break
                except:
                    sheet_names = []

            if not sheet_names:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No sheets in reference file workbook.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No sheets in reference file workbook {self.ref_file}.")
                return False

            for sheet in sheet_names:
                df = pd.read_excel(self.ref_file, sheet_name=sheet, engine=engine)

                if (any(col in df.columns for col in tenant_col)
                        and any(col in df.columns for col in object_col)
                        and any(col in df.columns for col in subnet_col)):
                    col_1 = [col for col in tenant_col if col in df.columns][0]  # Tenant
                    col_2 = [col for col in object_col if col in df.columns][0]  # Address object
                    col_3 = [col for col in subnet_col if col in df.columns][0]  # Subnet

                    data[sheet] = df[[col_1, col_2, col_3]].values.tolist()  # [Tenant, Address object, Subnet]

            if not data:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No subnets in the reference file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No subnets in the reference file {self.ref_file}.")
                return False

            for sheet in data.keys():
                for i, row in enumerate(data[sheet]):
                    tenant = str(row[0]).strip()
                    name = str(row[1]).strip()
                    subnet = str(row[2]).strip()
                    subnet_type = self.get_type(subnet)

                    if tenant == "nan":
                        tenant = ""
                    if name == "nan":
                        name = ""
                    if subnet == "nan":
                        subnet = ""

                    if subnet_type == "Invalid":
                        if not subnet:
                            self.ref_invalids.append([sheet, "Empty", i + 2])
                        else:
                            self.ref_invalids.append([sheet, subnet, i + 2])
                        # continue
                        self.refs.setdefault(sheet, []).append([tenant, name, subnet,
                                                                subnet,
                                                                subnet_type])
                    else:
                        self.ref_no += 1
                        self.refs.setdefault(sheet, []).append([tenant, name, subnet,
                                                                self.convert2ipaddress(subnet, subnet_type),
                                                                subnet_type])

            if not self.ref_no:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No valid subnets in the reference file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No valid subnets in the reference file {self.ref_file}.")
                return False

            self.parent.ref_row.checkbox_var.set(1)
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The reference is valid ({self.ref_no} Subnets).", "green", "arrow")
            self.parent.log.set(f"INFO - Reference file is valid ({self.ref_file}).")
            return True

        elif self.ref_file.lower().endswith(csv_ext):
            try:
                df = pd.read_csv(self.ref_file)
            except:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("Invalid CSV file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - Invalid CSV file {self.ref_file}.")
                return False

            if (any(col in df.columns for col in tenant_col)
                    and any(col in df.columns for col in object_col)
                    and any(col in df.columns for col in subnet_col)):
                col_1 = [col for col in tenant_col if col in df.columns][0]  # Tenant
                col_2 = [col for col in object_col if col in df.columns][0]  # Address object
                col_3 = [col for col in subnet_col if col in df.columns][0]  # Subnet

                data = df[[col_1, col_2, col_3]].values.tolist()  # [Tenant, Address object, Subnet]

            else:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No subnets in the reference file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No subnets in the reference file {self.ref_file}.")
                return False

            for i, row in enumerate(data):
                tenant = str(row[0]).strip()
                name = str(row[1]).strip()
                subnet = str(row[2]).strip()
                subnet_type = self.get_type(subnet)

                if tenant == "nan":
                    tenant = ""
                if name == "nan":
                    name = ""
                if subnet == "nan":
                    subnet = ""

                if subnet_type == "Invalid":
                    if not subnet:
                        self.ref_invalids.append(["CSV", "Empty", i + 2])
                    else:
                        self.ref_invalids.append(["CSV", subnet, i + 2])
                    # continue
                    self.refs.setdefault("CSV", []).append([tenant, name, subnet,
                                                            subnet,
                                                            subnet_type])
                else:
                    self.ref_no += 1
                    self.refs.setdefault("CSV", []).append([tenant, name, subnet,
                                                            self.convert2ipaddress(subnet, subnet_type),
                                                            subnet_type])

            if not self.ref_no:
                self.parent.set_info_status("ERROR", "red", "arrow")
                self.parent.set_info_message("No valid subnets in the reference file.", "red", "arrow")
                if start_flag:
                    self.parent.log.set(f"ERROR - No valid subnets in the reference file {self.ref_file}.")
                return False

            self.parent.ref_row.checkbox_var.set(1)
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"The reference is valid ({self.ref_no} Subnets).", "green", "arrow")
            self.parent.log.set(f"INFO - Reference file is valid ({self.ref_file}).")
            return True

    #######################################################

    def connect_pan(self,
                    ip: str = "",
                    username: str = "",
                    password: str = "",
                    vsys: str = "",
                    window: tk.Toplevel | None = None,
                    ) -> bool:

        def failed(error: str = ""):
            if error:
                self.parent.log.set(f"ERROR - Failed to connect to Palo Alto{f": {error}" if self.__DEBUG else ""}.")
            else:
                self.parent.log.set(f"ERROR - Failed to connect to Palo Alto.")
            self.parent.pan_row.button.config(state="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            self.disconnect_pan(False)

        if not ip.strip():
            ip = self.pan_ip
        if not username.strip():
            username = self.pan_username
        if not password:
            password = self.pan_password
        if not vsys.strip():
            vsys = self.pan_vsys

        ip = ip.strip()
        username = username.strip()
        vsys = vsys.strip()

        if self.ssh_pan:
            self.disconnect_pan(False)

        self.parent.disable_connect_buttons()
        self.parent.log.set("INFO - Connecting to Palo Alto...")

        # Check the credentials are not empty
        if any([ip == "", username == "", password == ""]):
            self.parent.pan_row.button.config(state="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            self.disconnect_pan(False)
            self.parent.log.set("ERROR - Palo Alto credentials are not set.")
            return False

        self.ssh_pan = SSHClient()
        self.ssh_pan.set_missing_host_key_policy(AutoAddPolicy())
        self.parent.pan_row.button.config(cursor="wait", text="Connecting")

        try:
            # Connect to Palo Alto
            __ssh_pan_thread = PropagatingThread(target=self.ssh_pan.connect,
                                                 kwargs={
                                                     "hostname": ip,
                                                     "username": username,
                                                     "password": password,
                                                     "timeout": 10
                                                 },
                                                 daemon=True,
                                                 name="ssh_pan_thread")
            __ssh_pan_thread.start()

            while __ssh_pan_thread.is_alive():
                self.parent.get_root().update()
                if isinstance(window, tk.Toplevel) and window.winfo_exists():
                    window.update()
                time.sleep(0.1)

            __ssh_pan_thread.join()

            # Check if the connection is successful
            if self.ssh_pan.get_transport().is_active():
                try:
                    transport = self.ssh_pan.get_transport()
                    transport.set_keepalive(30)
                    transport.send_ignore()
                except Exception as e:
                    failed(str(e))
                    return False
            else:
                failed()
                return False

            self.parent.pan_row.status.config(text="Connected", foreground="green")
            self.parent.log.set(f"INFO - Connected to Palo Alto Device {ip}.")

            try:
                self.pan_addresses = []
                if isinstance(self.ssh_pan, SSHClient) and self.ssh_pan.get_transport().is_active():
                    __import_pan_thread = PropagatingThread(target=self.import_pan,
                                                            kwargs={
                                                                "ip": ip,
                                                                "vsys": vsys,
                                                            },
                                                            daemon=True,
                                                            name="import_pan_thread")

                    __import_pan_thread.start()

                    while __import_pan_thread.is_alive():
                        self.parent.get_root().update()
                        if isinstance(window, tk.Toplevel) and window.winfo_exists():
                            window.update()
                        time.sleep(0.1)

                    __import_pan_thread.join()

            except Exception as e:
                self.parent.log.set(
                    f"ERROR - Failed to import Palo Alto addresses{f": {str(e)}" if self.__DEBUG else ""}.")

            self.parent.pan_row.button.config(text="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            return True

        except Exception as e:
            failed(str(e))
            return False

    def disconnect_pan(self, logging=True) -> None:
        try:
            if isinstance(self.ssh_pan, SSHClient):
                self.ssh_pan.close()
        finally:
            self.ssh_pan = None

            self.parent.pan_row.button.config(text="Connect", cursor="arrow")
            self.parent.pan_row.status.config(text="Not Connected", foreground="red")
            if logging:
                self.parent.log.set("INFO - Disconnected from Palo Alto Device.")
            self.parent.enable_connect_buttons()

    def import_pan(self, ip: str = "", vsys: str = "") -> bool:
        if not ip.strip():
            ip = self.pan_ip
        if not vsys.strip():
            vsys = self.pan_vsys

        ip = ip.strip()
        vsys = re.sub(" ", "", vsys.strip())  # No spaces allowed
        if any(sep in vsys for sep in self.separators):
            sep = [sep for sep in self.separators if sep in vsys][0]
            vsys = re.sub(f"{sep}+", sep, vsys.strip())
            vsys = re.sub(sep, r"\|", vsys.strip())

        __ssh_pan_shell = None
        self.pan_addresses = []

        if not isinstance(self.ssh_pan, SSHClient) or not self.ssh_pan.get_transport().is_active():
            return False

        try:
            # Invoke Shell
            try:
                # transport = self.ssh_pan.get_transport()
                # transport.default_window_size = 4 * 2**15  # Default 64 * 2**15
                __ssh_pan_shell = self.ssh_pan.invoke_shell()
            except Exception as e:
                self.parent.log.set(
                    f"ERROR - Exception invoking shell on Palo Alto{f": {str(e)}" if self.__DEBUG else ""}.")
                return False

            commands = ["set cli config-output-format set",
                        "set cli scripting-mode on",
                        "set cli pager off",
                        "configure",
                        "\r\n"]

            __ssh_pan_shell.sendall("\r\n".join(commands))

            while True:
                time.sleep(1)
                if __ssh_pan_shell.recv_ready():
                    _ = __ssh_pan_shell.recv(65535)
                    break
                elif __ssh_pan_shell.exit_status_ready():
                    exit_status = __ssh_pan_shell.recv_exit_status()
                    break
                elif __ssh_pan_shell.closed or __ssh_pan_shell.eof_received or not __ssh_pan_shell.active:
                    break

            __ssh_pan_shell.recv(65535)  # Clear buffer
            __ssh_pan_shell.sendall('\r\n')
            time.sleep(0.25)

            if vsys.lower() in ["", "any", "all"]:
                __ssh_pan_shell.sendall(f'show | match ip-netmask\\|ip-range\\|ip-wildcard\r\n')
            else:
                __ssh_pan_shell.sendall(f'show | match ip-netmask\\|ip-range\\|ip-wildcard | match "{vsys}"\r\n')

            # __ssh_pan_shell.sendall(" \r\n" * 10)  # Not needed but to make sure that all output are displayed

            count = 0
            max_count = 60  # Minimum time in seconds/10
            output = bytearray()
            timeout = time.time() + 120  # 2 Minutes timeout
            while True:
                time.sleep(.1)

                if __ssh_pan_shell.recv_ready():  # Wait for the command to be ready
                    count = 0
                    output.extend(__ssh_pan_shell.recv(5 * 1024 * 1024))
                elif __ssh_pan_shell.exit_status_ready():
                    exit_status = __ssh_pan_shell.recv_exit_status()
                    break
                elif __ssh_pan_shell.closed or __ssh_pan_shell.eof_received or not __ssh_pan_shell.active:
                    break
                else:
                    count += 1

                # Break the loop if no output is received for more than max_count seconds
                if count >= max_count:
                    break

                if time.time() > timeout:
                    break

            # Clean the output
            output = output.decode('utf-8')
            output = re.sub(" +", " ", output)
            output = re.sub("\x00*", "", output)
            output = re.sub("#|>", "\n", output)
            output = re.sub("[\n\r]+", "\n", output)
            output = [x.strip().split(" ") for x in output.split('\n') if "set " in x and ("address" in x
                                                                                           or "device-group" in x
                                                                                           or "shared" in x)]

            for line in output:
                v_sys, address_object, ip_address, ip_type = "", "", "", ""
                line = [x.strip() for x in line if x.strip()]

                if len(line) <= 3 or line[0] != "set":
                    continue

                if line[1] in ["address", "shared"]:
                    v_sys = "shared"
                    address_object = line[2] if line[1] == "address" else line[3]
                    ip_address = line[-1]

                elif line[1] == "device-group":
                    v_sys = line[2]
                    address_object = line[4]
                    ip_address = line[-1]

                else:
                    continue

                if not all([v_sys, address_object, ip_address]):
                    continue

                if address_object.lower().startswith("network_") and len(address_object) > 8:
                    address_object = address_object[8:]

                if self.get_type(address_object) != "Invalid":
                    continue

                ip_type = self.get_type(ip_address)
                if ip_type == "Invalid":
                    continue

                self.pan_addresses.append([v_sys,
                                           address_object,
                                           ip_address,
                                           self.convert2ipaddress(ip_address, ip_type),
                                           ip_type])

            if not self.pan_addresses:
                self.parent.set_info_status("INFO", "green", "arrow")
                self.parent.set_info_message("No addresses found in Palo Alto, Try again.", "red", "arrow")
                self.parent.log.set(f"INFO - No addresses found in Palo Alto ({ip}).")
                return False

            self.parent.pan_row.checkbox_var.set(1)
            self.parent.pan_row.status.config(text=f"{self.parent.pan_row.status["text"]} (Imported)")
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"Imported {len(self.pan_addresses)} addresses from Palo Alto.",
                                         "green", "arrow")
            self.parent.log.set(f"INFO - Imported {len(self.pan_addresses)} addresses from Palo Alto ({ip}).")
            return True

        except Exception as e:
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message(f"Failed to import Palo Alto addresses{f": {str(e)}" if self.__DEBUG else ""}."
                                         , "red", "arrow")
            self.parent.log.set(f"ERROR - Failed to import Palo Alto addresses{f": {str(e)}" if self.__DEBUG else ""}.")
            return False

    #######################################################

    def connect_forti(self,
                      ip: str = "",
                      port: int | str = 0,
                      username: str = "",
                      password: str = "",
                      vdom: str = "",
                      window: tk.Toplevel | None = None,
                      ) -> bool:

        if not ip.strip():
            ip = self.forti_ip
        if not port:
            port = self.forti_port
        if not username.strip():
            username = self.forti_username
        if not password:
            password = self.forti_password
        if not vdom.strip():
            vdom = self.forti_vdom

        ip = ip.strip()
        username = username.strip()
        vdom = vdom.strip()

        try:
            port = int(port)
        except:
            self.parent.forti_row.button.config(state="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            self.disconnect_forti(False)
            self.parent.log.set(f"ERROR - Invalid Port number {port}.")
            return False

        if self.forti_api:
            self.disconnect_forti(False)

        self.parent.disable_connect_buttons()
        self.parent.log.set("INFO - Connecting to FortiGate...")

        if any([ip == "", port < 1, port > 65535, username == "", password == ""]):
            self.parent.forti_row.button.config(state="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            self.disconnect_forti(False)
            self.parent.log.set("ERROR - FortiGate credentials are not set.")
            return False

        self.parent.forti_row.button.config(cursor="wait", text="Connecting")
        try:
            self.forti_api = FortiGateAPI(host=ip,
                                          port=port,
                                          username=username,
                                          password=password,
                                          vdom=vdom,
                                          timeout=5,
                                          scheme="https")
            self.forti_api.login()

        except:
            if self.parent.start_status():
                self.parent.log.set(f"ERROR - Failed to connect to FortiGate through HTTPS on port {port}.")
            try:
                self.forti_api = FortiGateAPI(host=ip,
                                              port=port,
                                              username=username,
                                              password=password,
                                              vdom=vdom,
                                              timeout=5,
                                              scheme="http")
                self.forti_api.login()

            except:
                if self.parent.start_status():
                    self.parent.log.set(f"ERROR - Failed to connect to FortiGate through HTTP on port {port}.")
                    self.disconnect_forti()
                else:
                    self.parent.log.set(f"ERROR - Failed to connect to FortiGate: Timeout.")
                    self.disconnect_forti(False)

                self.parent.forti_row.button.config(text="Connect", cursor="arrow")
                self.parent.enable_connect_buttons()
                return False

        self.parent.forti_row.status.config(text="Connected", foreground="green")
        self.parent.log.set(f"INFO - Connected to FortiGate Device {ip}.")

        try:
            __import_forti_thread = PropagatingThread(target=self.import_forti,
                                                      kwargs={
                                                          "ip": ip,
                                                          "vdom": vdom,
                                                      },
                                                      daemon=True,
                                                      name="import_forti_thread")
            __import_forti_thread.start()

            while __import_forti_thread.is_alive():
                self.parent.get_root().update()
                if isinstance(window, tk.Toplevel) and window.winfo_exists():
                    window.update()
                time.sleep(0.1)

            __import_forti_thread.join()

        except Exception as e:
            self.forti_addresses = []
            self.parent.log.set(f"ERROR - Failed to import FortiGate addresses{f": {str(e)}" if self.__DEBUG else ""}.")

        self.parent.forti_row.button.config(text="Connect", cursor="arrow")
        self.parent.enable_connect_buttons()
        return True

    def disconnect_forti(self, logging=True):
        try:
            if isinstance(self.forti_api, FortiGateAPI):
                self.forti_api.logout()
        finally:
            self.forti_api = None

            self.parent.forti_row.button.config(text="Connect", cursor="arrow")
            self.parent.forti_row.status.config(text="Not Connected", foreground="red")
            if logging:
                self.parent.log.set("INFO - Disconnected from FortiGate Device.")
            self.parent.enable_connect_buttons()

    def import_forti(self, ip: str = "", vdom: str = "") -> bool:
        if not ip.strip():
            ip = self.forti_ip
        if not vdom.strip():
            vdom = self.forti_vdom

        ip = ip.strip()
        vdom = re.sub(" ", "", vdom.strip())  # No spaces allowed
        if any(sep in vdom for sep in self.separators):
            sep = [sep for sep in self.separators if sep in vdom][0]
            vdom = re.sub(f"{sep}+", sep, vdom.strip())
            vdom = [v.strip() for v in vdom.split(sep) if v.strip()]

        self.forti_addresses = []
        __ip_keys = ['subnet', 'start-ip', 'end-ip']

        if not isinstance(self.forti_api, FortiGateAPI):
            return False

        try:
            __device_vdoms = [v["name"] for v in self.forti_api.cmdb.system.vdom.get()]

            if vdom.lower() in ["", "any", "all"]:
                __vdoms = __device_vdoms.copy()

                if not __vdoms:
                    self.parent.log.set(f"ERROR - No VDOMs found in FortiGate {ip}.")
                    return False
            else:
                __tmp = []
                for v in vdom:
                    if v in __device_vdoms:
                        __tmp.append(v)
                    else:
                        self.parent.log.set(f"ERROR - VDOM {v} not found in FortiGate {ip}.")
                __vdoms = __tmp.copy()

                if not __vdoms:
                    self.parent.log.set(f"ERROR - The selected VDOMs are not found in FortiGate {ip}.")
                    return False

            items = []
            for vdom in __vdoms:
                self.forti_api.vdom = vdom
                __tmp_item = self.forti_api.cmdb.firewall.address.get()
                for i in range(len(__tmp_item)):
                    __tmp_item[i]["vdom"] = vdom
                items.extend(__tmp_item)

            for i in range(len(items)):
                if len([items[i].get(key) for key in __ip_keys if items[i].get(key)]):
                    if "subnet" in items[i].keys():
                        ip_netmask = items[i]["subnet"].strip().split(" ")
                        if len(ip_netmask) == 2:
                            items[i]["subnet"] = "/".join([ip_netmask[0].strip(),
                                                           str(ipaddress.ip_network(
                                                               f"0.0.0.0/{ip_netmask[1].strip()}").prefixlen)])
                    elif "start-ip" in items[i].keys() and "end-ip" in items[i].keys():
                        items[i]["subnet"] = f"{items[i]['start-ip'].strip()}-{items[i]['end-ip'].strip()}"

            for i in range(len(items) - 1, -1, -1):
                if (("subnet" not in items[i].keys())
                        or (items[i]["subnet"] in ["0.0.0.0/32", "0.0.0.0/0"])):
                    items.pop(i)
                    continue

                if items[i]["name"].lower().startswith("network_") and len(items[i]["name"]) > 8:
                    items[i]["name"] = items[i]["name"][8:]

                if self.get_type(items[i]["name"]) != "Invalid":
                    items.pop(i)

            for item in items:
                item_type = self.get_type(item["subnet"])
                self.forti_addresses.append([item["vdom"],
                                             item["name"],
                                             item["subnet"],
                                             self.convert2ipaddress(item["subnet"], item_type),
                                             item_type])

            if not self.forti_addresses:
                self.parent.set_info_status("INFO", "green", "arrow")
                self.parent.set_info_message("No addresses found in FortiGate.", "red", "arrow")
                self.parent.log.set(f"INFO - No addresses found in FortiGate ({ip}).")
                return False

            self.parent.forti_row.checkbox_var.set(1)
            self.parent.forti_row.status.config(text=f"{self.parent.forti_row.status["text"]} (Imported)")
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"Imported {len(self.forti_addresses)} addresses from FortiGate.",
                                         "green", "arrow")
            self.parent.log.set(f"INFO - Imported {len(self.forti_addresses)} addresses from FortiGate ({ip}).")
            return True

        except Exception as e:
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message(f"Failed to import FortiGate addresses{f": {str(e)}" if self.__DEBUG else ""}."
                                         , "red", "arrow")
            self.parent.log.set(f"ERROR - Failed to import FortiGate addresses{f": {str(e)}" if self.__DEBUG else ""}.")
            return False

    #######################################################

    def connect_apic(self,
                     ip: str = "",
                     username: str = "",
                     password: str = "",
                     apic_class: str = "",
                     window: tk.Toplevel | None = None,
                     ) -> bool:

        def failed(error: str = ""):
            if error:
                self.parent.log.set(f"ERROR - Failed to connect to APIC{f": {str(error)}" if self.__DEBUG else ""}.")
            else:
                self.parent.log.set(f"ERROR - Failed to connect to APIC.")
            self.parent.apic_row.button.config(state="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            self.disconnect_apic(False)

        if not ip.strip():
            ip = self.apic_ip
        if not username.strip():
            username = self.apic_username
        if not password:
            password = self.pan_password
        if not apic_class.strip():
            apic_class = self.apic_class

        ip = ip.strip()
        username = username.strip()
        apic_class = apic_class.strip()

        if self.ssh_apic:
            self.disconnect_apic(False)

        self.parent.disable_connect_buttons()
        self.parent.log.set("INFO - Connecting to APIC...")

        if any([ip == "", username == "", password == ""]):
            self.parent.apic_row.button.config(state="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            self.disconnect_apic(False)
            self.parent.log.set("ERROR - APIC credentials are not set.")
            return False

        self.ssh_apic = SSHClient()
        self.ssh_apic.set_missing_host_key_policy(AutoAddPolicy())
        self.parent.apic_row.button.config(cursor="wait", text="Connecting")

        try:
            __ssh_apic_thread = PropagatingThread(target=self.ssh_apic.connect,
                                                  kwargs={
                                                      "hostname": ip,
                                                      "username": username,
                                                      "password": password,
                                                      "timeout": 10
                                                  },
                                                  daemon=True,
                                                  name="ssh_apic_thread")
            __ssh_apic_thread.start()

            while __ssh_apic_thread.is_alive():
                self.parent.get_root().update()
                if isinstance(window, tk.Toplevel) and window.winfo_exists():
                    window.update()
                time.sleep(0.1)

            __ssh_apic_thread.join()

            if self.ssh_apic.get_transport().is_active():
                try:
                    transport = self.ssh_apic.get_transport()
                    transport.set_keepalive(30)
                    transport.send_ignore()
                except Exception as e:
                    failed(str(e))
                    return False
            else:
                failed()
                return False

            self.parent.apic_row.status.config(text="Connected", foreground="green")
            self.parent.log.set(f"INFO - Connected to APIC Device {ip}.")

            try:
                self.apic_addresses = []
                if isinstance(self.ssh_apic, SSHClient) and self.ssh_apic.get_transport().is_active():
                    __import_apic_thread = PropagatingThread(target=self.import_apic,
                                                             kwargs={
                                                                 "ip": ip,
                                                                 "apic_class": apic_class,
                                                             },
                                                             daemon=True,
                                                             name="import_apic_thread")

                    __import_apic_thread.start()

                    while __import_apic_thread.is_alive():
                        self.parent.get_root().update()
                        if isinstance(window, tk.Toplevel) and window.winfo_exists():
                            window.update()
                        time.sleep(0.1)

                    __import_apic_thread.join()

            except Exception as e:
                self.parent.log.set(f"ERROR - Failed to import APIC addresses{f": {str(e)}" if self.__DEBUG else ""}.")

            self.parent.apic_row.button.config(text="Connect", cursor="arrow")
            self.parent.enable_connect_buttons()
            return True

        except Exception as e:
            failed(str(e))
            return False

    def disconnect_apic(self, logging=True):
        try:
            if isinstance(self.ssh_apic, SSHClient):
                self.ssh_apic.close()
        finally:
            self.ssh_apic = None

            self.parent.apic_row.button.config(text="Connect", cursor="arrow")
            self.parent.apic_row.status.config(text="Not Connected", foreground="red")
            if logging:
                self.parent.log.set("INFO - Disconnected from APIC Device.")
            self.parent.enable_connect_buttons()

    def import_apic(self, ip: str = "", apic_class: str = "") -> bool:
        if not ip.strip():
            ip = self.apic_ip
        if not apic_class.strip():
            apic_class = self.apic_class

        ip = ip.strip()
        apic_class = re.sub(" ", "", apic_class.strip())  # No spaces allowed
        if any(sep in apic_class for sep in self.separators):
            sep = [sep for sep in self.separators if sep in apic_class][0]
            apic_class = re.sub(f"{sep}+", sep, apic_class.strip())
            apic_class = ",".join([v.strip() for v in apic_class.split(sep) if v.strip()])

        self.apic_addresses = []

        if not isinstance(self.ssh_apic, SSHClient) or not self.ssh_apic.get_transport().is_active():
            return False

        try:
            output = self.ssh_apic.exec_command(f"moquery -c {apic_class} " +
                                                r'| grep -E "^dn[ \t]*:.+\[.*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+.*\]" | cut -d ":" -f 2 | cut -d " " -f 2')[
                1]
            output = output.read().decode("utf-8").strip()
            output = re.sub(" +", " ", output)
            output = re.sub(r"[\[\]]", "", output)
            output = output.split("\n")

            for line in output:
                tenant, address_object, ip_address, ip_type = "", "", "", ""
                line = [x.strip() for x in line.strip().split("/") if x.strip()]

                try:
                    if 0 <= int(line[-1]) <= 128:
                        line[-2] = f"{line[-2]}/{line[-1]}"
                        line = line[:-1]
                finally:
                    pass

                if len(line) == 4:
                    if line[1].lower().startswith("tn-"):
                        tenant = line[1][3:]
                    else:
                        tenant = line[1]

                    if line[2].lower().startswith("bd-"):
                        address_object = line[2][3:]
                    else:
                        address_object = line[2]

                    if line[-1].lower().startswith("subnet-"):
                        ip_address = line[-1][7:]

                elif len(line) == 5:
                    if line[1].lower().startswith("tn-"):
                        tenant = line[1][3:]
                    else:
                        tenant = line[1]

                    if (line[2].lower().startswith("ap-")
                            and line[3].lower().startswith("epg-")):
                        address_object = f"{line[2][3:]}-{line[3][4:]}"
                    else:
                        address_object = f"{line[2]}-{line[3]}"

                    if line[-1].lower().startswith("subnet-"):
                        ip_address = line[-1][7:]

                if not all([tenant, address_object, ip_address]):
                    continue

                if self.get_type(address_object) != "Invalid":
                    continue

                ip_type = self.get_type(ip_address)
                if ip_type == "Invalid":
                    continue

                self.apic_addresses.append([tenant,
                                            f"{tenant}-{address_object}",
                                            ip_address,
                                            self.convert2ipaddress(ip_address, ip_type),
                                            ip_type])

            if not self.apic_addresses:
                self.parent.set_info_status("INFO", "green", "arrow")
                self.parent.set_info_message("No addresses found in APIC.", "red", "arrow")
                self.parent.log.set(f"INFO - No addresses found in APIC ({ip}).")
                return False

            self.parent.apic_row.checkbox_var.set(1)
            self.parent.apic_row.status.config(text=f"{self.parent.apic_row.status["text"]} (Imported)")
            self.parent.set_info_status("INFO", "green", "arrow")
            self.parent.set_info_message(f"Imported {len(self.apic_addresses)} addresses from APIC.",
                                         "green", "arrow")
            self.parent.log.set(f"INFO - Imported {len(self.apic_addresses)} addresses from APIC ({ip}).")
            return True

        except Exception as e:
            self.parent.set_info_status("ERROR", "red", "arrow")
            self.parent.set_info_message(f"Failed to import APIC addresses{f": {str(e)}" if self.__DEBUG else ""}.",
                                         "red", "arrow")
            self.parent.log.set(f"ERROR - Failed to import APIC addresses{f": {str(e)}" if self.__DEBUG else ""}.")
            return False

    #######################################################

    def check_dns_servers(self, *servers) -> list[str]:
        if servers:
            if (isinstance(servers, tuple)
                    and len(servers) == 1
                    and isinstance(servers[0], (tuple, list, set))):
                servers = servers[0]
            else:
                servers = list(servers)
        else:
            servers = self.dns_servers

        if not servers:
            return []

        self.parent.disable_connect_buttons()
        self.parent.dns_row.button.config(cursor="wait", text="Checking")
        self.parent.log.set("INFO - Checking DNS Servers...")

        output = []
        for server in servers:
            if self.get_type(server) != "IP":
                continue

            try:
                if ipaddress.ip_address(server).version != 4:
                    continue

                __socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                __socket.settimeout(2.25)
                result = __socket.connect_ex((server, 53))

                if result == 0:
                    output.append(server)
                __socket.close()

            finally:
                pass

        if not output:
            self.parent.dns_row.status.config(text="No reachable DNS servers", foreground="red")
            self.parent.dns_row.checkbox_var.set(0)
            self.parent.log.set(f"ERROR - No reachable DNS servers: {', '.join(servers)}.")

        else:
            self.parent.dns_row.status.config(text=f"{len(output)} reachable DNS servers", foreground="green")
            # self.parent.dns_row.checkbox_var.set(1)
            self.parent.log.set(f"INFO - DNS Servers are reachable: {', '.join(output)}.")

            self.dns_resolver = dns.resolver.Resolver()
            self.resolvers = output.copy()
            self.dns_resolver.nameservers = self.resolvers
            self.dns_resolver.timeout = 1

        self.parent.dns_row.button.config(text="Check", cursor="arrow")
        self.parent.enable_connect_buttons()
        return output

    #######################################################

    def save_outputs(self) -> str:
        __filename = f"{datetime.now().strftime('%Y.%m.%d_%H.%M.%S')}_Output.xlsx"
        while True:
            self.output_file = filedialog.SaveAs(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")],
                                                 parent=self.parent.get_root(), title="Save As", initialfile=__filename,
                                                 initialdir=".", confirmoverwrite=False).show()

            if not self.output_file:
                if tk.messagebox.askyesno("Save As", "Do you want to cancel saving the outputs?",
                                          parent=self.parent.get_root(), icon="warning", default="no"):
                    return "Cancel"
                else:
                    continue

            elif not self.output_file.lower().endswith(".xlsx"):
                self.output_file += ".xlsx"

            if os.path.isfile(self.output_file):
                if not tk.messagebox.askyesno("Save As", "The file already exists. Do you want to overwrite it?",
                                              parent=self.parent.get_root(), icon="warning", default="no"):
                    continue

            __filename = self.output_file.split("/")[-1]
            break

        headers = ["Subnet", "Reference", "Tenant", "Address Object", "Ref Subnet", "Type", "S/M"]

        try:
            workbook = xlsxwriter.Workbook(self.output_file)
            header_format = workbook.add_format({'bold': True, 'font_size': 12, 'align': 'center', 'valign': 'vcenter'})
            text_format = workbook.add_format({'text_wrap': True, 'valign': 'vcenter'})

            for sheet in self.outputs.keys():
                worksheet = workbook.add_worksheet(sheet)
                worksheet.write_row('A1', headers, header_format)
                for i in range(len(self.outputs[sheet][0])):
                    worksheet.write_row(f'A{i + 2}',
                                        [self.outputs[sheet][x][i] for x in range(len(self.outputs[sheet]))],
                                        text_format)
                worksheet.freeze_panes(1, 0)
                worksheet.autofilter(0,
                                     0,
                                     len(self.outputs[sheet][0]) - 1 if len(self.outputs[sheet][0]) > 1 else 1,
                                     len(headers) - 1 if len(headers) > 1 else 1
                                     )
                worksheet.autofit()

            workbook.close()
            self.parent.log.set(f"INFO - Outputs saved to {self.output_file}.")
            return __filename

        except Exception as e:
            self.parent.log.set(f"ERROR - Failed to save outputs{f": {str(e)}" if self.__DEBUG else ""}.")
            return "Error"

    def get_type(self, subnet) -> str:
        if not isinstance(subnet, (str,
                                   ipaddress.IPv4Address,
                                   ipaddress.IPv6Address,
                                   ipaddress.IPv4Network,
                                   ipaddress.IPv6Network)):
            return "Invalid"

        if isinstance(subnet, ipaddress.IPv4Address) or isinstance(subnet, ipaddress.IPv6Address):
            return "IP"

        elif isinstance(subnet, ipaddress.IPv4Network) or isinstance(subnet, ipaddress.IPv6Network):
            return "Subnet"

        subnet = str(subnet).strip()

        try:  # IP
            if subnet.endswith("/32") and ipaddress.ip_address(subnet[:-3]):
                return "IP"
        except:
            pass

        try:  # IP
            if subnet.endswith("/128") and ipaddress.ip_address(subnet[:-4]):
                return "IP"
        except:
            pass

        try:  # IP
            if "/" not in subnet and ipaddress.ip_address(subnet):
                return "IP"
        except:
            pass

        try:  # Subnet
            if ipaddress.ip_network(subnet, strict=False):
                return "Subnet"
        except:
            pass

        try:  # Range
            if "-" in subnet:
                __range = subnet.split("-")
                if len(__range) == 2 and self.get_type(__range[0]) == "IP" and self.get_type(__range[1]) == "IP":
                    return "Range"
        except:
            pass

        try:  # List
            if any(sep in subnet for sep in self.separators):
                sep = [sep for sep in self.separators if sep in subnet][0]
                __list = re.sub(f"{sep}+", sep, subnet.strip())
                __list = [x.strip() for x in __list.split(sep) if x.strip()]
                for item in __list:
                    if self.get_type(item) == "Invalid":
                        return "Invalid"
                return "List"
        except:
            pass

        return "Invalid"

    def convert2ipaddress(self, address, address_type: str):
        try:
            if isinstance(address_type, str) and isinstance(address, str):
                address = address.strip()

                if address_type == "IP":
                    __ip = re.sub("/32", "", address)
                    __ip = re.sub("/128", "", __ip)
                    return ipaddress.ip_address(__ip)

                elif address_type == "Subnet":
                    return ipaddress.ip_network(address, strict=False)

                elif address_type == "Range":
                    __range = [x.strip() for x in address.split("-")]
                    if ipaddress.ip_address(__range[0]) > ipaddress.ip_address(__range[1]):
                        __range[0], __range[1] = __range[1], __range[0]
                    return [ipaddress.ip_address(__range[0]), ipaddress.ip_address(__range[1])]

                elif address_type == "List":
                    sep = [sep for sep in self.separators if sep in address][0]
                    address = re.sub(f"{sep}+", sep, address.strip())
                    return [self.convert2ipaddress(item.strip(), self.get_type(item.strip())) for item in
                            address.split(sep) if item.strip()]

                else:
                    return address

            elif isinstance(address_type, str) and isinstance(address, (list,
                                                                        ipaddress.IPv4Address,
                                                                        ipaddress.IPv6Address,
                                                                        ipaddress.IPv4Network,
                                                                        ipaddress.IPv6Network)):
                if address_type in ["IP", "Subnet"]:
                    return str(address)

                elif address_type == "Range":
                    return f"{str(address[0])}-{str(address[1])}"

                elif address_type == "List":
                    return "\n".join([str(ip) for ip in address])

                else:
                    return address

            else:
                return address

        except:
            return address

    def IsinSubnet(self, ip, ip_type, subnet, subnet_type) -> bool:

        try:
            if isinstance(ip, str):
                ip = self.convert2ipaddress(ip, ip_type)

            if isinstance(subnet, str):
                subnet = self.convert2ipaddress(subnet, subnet_type)

            if (ip_type == "Invalid" or subnet_type == "Invalid" or
                    (ip_type in ["Subnet", "Range", "List"] and subnet_type == "IP")):
                return False

            elif ip_type == "IP" and subnet_type == "IP":
                if ip == subnet:
                    return True

            elif ip_type == "IP" and subnet_type == "Subnet":
                if ip in subnet:
                    return True

            elif ip_type == "IP" and subnet_type == "Range" and isinstance(subnet, list):
                if subnet[0] <= ip <= subnet[1]:
                    return True

            elif ip_type == "IP" and subnet_type == "List" and isinstance(subnet, list):
                for item in subnet:
                    if self.IsinSubnet(ip, ip_type, item, self.get_type(item)):
                        return True

            elif ip_type == "Subnet" and subnet_type == "Subnet":
                if ((ip == subnet) or
                        (ip.network_address >= subnet.network_address
                         and ip.broadcast_address <= subnet.broadcast_address)):
                    return True

            elif ip_type == "Subnet" and subnet_type == "Range" and isinstance(subnet, list):
                if ip.network_address >= subnet[0] and ip.broadcast_address <= subnet[1]:
                    return True

            elif ip_type == "Subnet" and subnet_type == "List" and isinstance(subnet, list):
                for item in subnet:
                    if self.IsinSubnet(ip, ip_type, item, self.get_type(item)):
                        return True

            elif ip_type == "Range" and subnet_type == "Subnet" and isinstance(ip, list):
                if ip[0] >= subnet.network_address and ip[1] <= subnet.broadcast_address:
                    return True

            elif ip_type == "Range" and subnet_type == "Range" and isinstance(ip, list) and isinstance(subnet, list):
                if ip[0] >= subnet[0] and ip[1] <= subnet[1]:
                    return True

            elif ip_type == "Range" and subnet_type == "List" and isinstance(ip, list) and isinstance(subnet, list):
                for item in subnet:
                    if self.IsinSubnet(ip, ip_type, item, self.get_type(item)):
                        return True

            elif ip_type == "List" and subnet_type == "Subnet" and isinstance(ip, list):
                flag = 0
                for ip_tmp in ip:
                    if self.IsinSubnet(ip_tmp, self.get_type(ip_tmp), subnet, subnet_type):
                        flag += 1
                if flag == len(ip):
                    return True

            elif ip_type == "List" and subnet_type == "Range" and isinstance(ip, list) and isinstance(subnet, list):
                flag = 0
                for ip_tmp in ip:
                    if self.IsinSubnet(ip_tmp, self.get_type(ip_tmp),
                                       subnet, subnet_type):
                        flag += 1
                if flag == len(ip):
                    return True

            elif ip_type == "List" and subnet_type == "List" and isinstance(ip, list) and isinstance(subnet, list):
                flag = 0
                for ip_tmp in ip:
                    for subnet_tmp in subnet:
                        if self.IsinSubnet(ip_tmp, self.get_type(ip_tmp),
                                           subnet_tmp, self.get_type(subnet_tmp)):
                            flag += 1
                            break
                if flag == len(ip):
                    return True

            return False

        except Exception as e:
            if not isinstance(ip, str):
                ip = self.convert2ipaddress(ip, ip_type)
            if not isinstance(subnet, str):
                subnet = self.convert2ipaddress(subnet, subnet_type)

            self.parent.log.set(f"ERROR - Failed checking {ip} in {subnet}{f": {str(e)}" if self.__DEBUG else ""}")
            return False

    def Translate(self) -> None:
        self.parent.pre_start()
        __start_flag = self.parent.start_status()
        __stop_flag = self.parent.stop_status()
        flags = self.parent.get_methods_flags()
        self.parent.progress_bar.config(value=0, maximum=self.all_inputs_no)
        self.parent.progress_percentage.config(text="%0", foreground="black")

        self.parent.set_info_status("INFO", "green", "arrow")
        self.parent.set_info_message("Translation started.", "green", "arrow")

        counter = 0
        t1 = time.time()
        for sheet in self.inputs.keys():
            self.outputs[sheet] = [[] for _ in range(7)]
            for i, subnet in enumerate(self.inputs[sheet]):

                __start_flag = self.parent.start_status()
                __stop_flag = self.parent.stop_status()

                while __stop_flag:
                    __start_flag = self.parent.start_status()
                    __stop_flag = self.parent.stop_status()
                    if self.__stop:
                        return
                    if not __start_flag:
                        break
                else:
                    if not __start_flag:
                        break

                self.outputs[sheet][0].append(subnet[0])

                counter += 1
                t2 = time.time()
                elapsed_time = timedelta(seconds=round(t2 - t1))
                remaining_time = timedelta(seconds=round(((t2 - t1) / counter) * (self.all_inputs_no - counter)))
                self.parent.set_info_message(f"Time Elapsed: {elapsed_time}  -  Time Remaining: {remaining_time}",
                                             "green", "arrow")
                self.parent.progress_percentage.config(text=f"%{int((counter / self.all_inputs_no) * 100)}")
                self.parent.progress_bar.config(value=counter)

                if subnet[2] == "Invalid":
                    self.outputs[sheet][1].append("")
                    self.outputs[sheet][2].append("")
                    self.outputs[sheet][3].append(subnet[0])
                    self.outputs[sheet][4].append("")
                    self.outputs[sheet][5].append("Invalid")
                    self.outputs[sheet][6].append("None")
                    continue

                __ref = []
                __tenant = []
                __object = []
                __address = []
                __type = []

                if flags[0]:
                    for ref_sheet in self.refs.keys():
                        for j, ref_row in enumerate(self.refs[ref_sheet]):
                            if self.IsinSubnet(subnet[1], subnet[2], ref_row[3], ref_row[4]):
                                __ref.append(f"Ref - {ref_sheet} row {j + 2}")
                                __tenant.append(ref_row[0])
                                __object.append(ref_row[1])
                                __address.append(ref_row[2])
                                __type.append(ref_row[4])

                if flags[1]:
                    for ref_row in self.pan_addresses:
                        if self.IsinSubnet(subnet[1], subnet[2], ref_row[3], ref_row[4]):
                            __ref.append(f"PAN - {ref_row[0]}")
                            __tenant.append(ref_row[0])
                            __object.append(ref_row[1])
                            __address.append(ref_row[2])
                            __type.append(ref_row[4])

                if flags[2]:
                    for ref_row in self.forti_addresses:
                        if self.IsinSubnet(subnet[1], subnet[2], ref_row[3], ref_row[4]):
                            __ref.append(f"FGT - {ref_row[0]}")
                            __tenant.append(ref_row[0])
                            __object.append(ref_row[1])
                            __address.append(ref_row[2])
                            __type.append(ref_row[4])

                if flags[3]:
                    for ref_row in self.apic_addresses:
                        if self.IsinSubnet(subnet[1], subnet[2], ref_row[3], ref_row[4]):
                            __ref.append(f"ACI - {ref_row[0]}")
                            __tenant.append(ref_row[0])
                            __object.append(ref_row[1])
                            __address.append(ref_row[2])
                            __type.append(ref_row[4])

                if flags[4] and subnet[2] in ["IP", "List"]:
                    if subnet[2] == "IP":
                        subnet[1] = [subnet[1]]

                    __hostname = []
                    for ip in subnet[1]:
                        if self.get_type(ip.compressed) == "IP":
                            try:
                                __domain = str(self.dns_resolver.resolve_address(ip.compressed, search=True)[0])

                                if __domain:
                                    __hostname.append(__domain)
                            except:
                                pass

                    if __hostname:
                        __ref.append("DNS")
                        __tenant.append("DNS")
                        __object.append("\n".join(__hostname))
                        __address.append("\n".join([x.compressed for x in subnet[1]]))
                        __type.append("Domain Name")

                output_no = len(__ref)
                if not output_no:
                    self.outputs[sheet][1].append("")
                    self.outputs[sheet][2].append("")
                    self.outputs[sheet][3].append(subnet[0])
                    self.outputs[sheet][4].append("")
                    self.outputs[sheet][5].append("Not Found")
                    self.outputs[sheet][6].append("None")
                    continue

                elif output_no == 1:
                    self.outputs[sheet][6].append("Single")
                elif output_no > 1:
                    self.outputs[sheet][6].append("Multiple")

                self.outputs[sheet][1].append("\n\n".join(__ref))
                self.outputs[sheet][2].append("\n\n".join(__tenant))
                self.outputs[sheet][3].append("\n\n".join(__object))
                self.outputs[sheet][4].append("\n\n".join(__address))
                self.outputs[sheet][5].append("\n\n".join(__type))

            else:
                if not __start_flag:
                    break

        if self.parent.progress_bar['value'] >= self.all_inputs_no:
            self.parent.progress_percentage.config(text="%100", foreground="green")
        else:
            self.parent.progress_percentage.config(foreground="red")

        t2 = time.time()
        __filename = str(self.save_outputs())

        if __filename not in ["Error", "Cancel"]:
            self.parent.set_info_status(f"INFO - Time Elapsed: {timedelta(seconds=round(t2 - t1))}", "green", "arrow")
            self.parent.set_info_message(f"Outputs are saved into '{__filename}' file.", "green", "hand2")
            self.parent.info_msg_label.bind("<Button-1>", lambda e: os.startfile(self.output_file))
            self.parent.log.set(f"INFO - Translation completed. Outputs saved in {__filename}.")
        elif __filename == "Cancel":
            self.parent.set_info_status(f"INFO - Time Elapsed: {timedelta(seconds=round(t2 - t1))}", "green", "arrow")
            self.parent.set_info_message("Saving the outputs is cancelled.", "red", "arrow")
            self.parent.log.set("INFO - Saving the outputs is cancelled.")
        else:
            self.parent.set_info_status(f"ERROR - Time Elapsed: {timedelta(seconds=round(t2 - t1))}", "red", "arrow")
            self.parent.set_info_message("Failed to save the outputs.", "red", "arrow")
            self.parent.log.set("ERROR - Failed to save the outputs.")

        self.parent.log.set(f"INFO - Translation completed in {timedelta(seconds=round(t2 - t1))}.")
        self.parent.post_start()
        self.clear_var()
        self.parent.get_root().update()
        return

    #######################################################
